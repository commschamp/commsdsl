# "C" Interface

The [CommsChampion Ecosystem](https://commschamp.github.io/) is mostly about C++ and embedded systems.
Usage of the **commsdsl2c** code generator allows creation of the "C" interface to the C++ protocol
definition generated by the **commsdsl2comms**.

## Build Order

- Build and install [COMMS Library](https://github.com/commschamp/comms) project.
- Generate the protocol definition files using **commsdsl2comms**.
- Properly build and install the generated protocol definition project. It will generate appropriate cmake config
  file allowing the protocol headers only library to be found using `find_package()`.
- Generate the "C" interface project using **commsdsl2c**. It generates **CMakeLists.txt** file allowing the generated project being built
  separately.
- Build the project generated by the **commsdsl2c** setting relevant pathes to find its dependencies.

## Produced Output

- **include** folder - Contains header files with the "C" interface. All header files with reside in `c_cc` subfolder.
- **cc_c** folder - Contains source files with "C" interface functions.
- **CMakeLists.txt** - CMake project definition file allowing output to be built as a separate CMake project.

## Generated CMake Project
As it was mentioned above, the output of the **commsdsl2c**
(like any other [commsdsl](https://github.com/commschamp/commsdsl) code generator) contains **CMakeLists.txt**.
It can be used to build it as a separate cmake project.

Please open the generated **CMakeLists.txt** and see the build configuration.

Note that the dependencies for the generated project are [COMMS Library](https://github.com/commschamp/comms) and
the protocol definition project generated by the **commsdsl2comms**.

There are 2 ways to bring these dependencies in. Both of them are headers only libraries.

- The relevant include directories can be brought in using **OPT_EXTRA_INCLUDE_DIRS** cmake variable.
- In case the dependency projects are built and installed, then they can be brought in using the standard cmake way of specifying relevant installation paths with
  the **CMAKE_PREFIX_PATH** variable, and enabling the usage of the `find_package()` with the
  **OPT_FIND_COMMS** and **OPT_FIND_PROTOCOL** options enabled.

## Class Naming
The C++ scope of the class is flattened by replacing `::` with `_`.

For example:
```xml
<shema name="my_prot">
    <fields>
        <int name="F1" type="uint32" />
    </fields>

    <message name="Msg1" id="1">
        <ref field="F1" />
    </message>
</schema>
```

The generated "C" interface handlers are not prefixed with the protocol name namespace. It means that the
types for the entities above will be `my_prot_field_F1` for the global field `F1` and `my_prot_message_Msg1` for the
message `Msg1`.

The original protocol definition classes (generated by the **commsdsl2comms**) reside in the
`include/my_prot/field/F1.h` and `include/my_prot/message/Msg1`.

To differentiate between the include paths of the original class and the wrapper, the **commsdsl2c** adds
top level `cc_c` folder, so the generated class definition files reside in
`include/cc_c/my_prot/field/F1.h` and `include/cc_c/my_prot/message/Msg1.h` respectively.

The implemented functions reside in the source files
`cc_c/my_prot/field/F1.cpp` and `cc_c/my_prot/message/Msg1.cpp` respectively.

## Member Function Naming
All the member functions of the classes generated by the **commsdsl2comms** are translated into "C" functions
with a full [class name](#class-naming) prefix. For example function to acquire access to the `F1` field member of the `Msg1` message
in the example above will be:
```c
my_prot_message_Msg1Fields_F1* my_prot_message_Msg1_field_f1(my_prot_message_Msg1* msg);
```
Note that all "member functions" will accept a handler to their object as their first parameter.


