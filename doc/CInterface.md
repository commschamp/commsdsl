# "C" Interface

The [CommsChampion Ecosystem](https://commschamp.github.io/) is mostly about C++ and embedded systems.
Usage of the **commsdsl2c** code generator allows creation of the "C" interface to the C++ protocol
definition generated by the **commsdsl2comms**.

## Build Order

- Build and install [COMMS Library](https://github.com/commschamp/comms) project.
- Generate the protocol definition files using **commsdsl2comms**.
- Properly build and install the generated protocol definition project. It will generate appropriate cmake config
  file allowing the protocol headers only library to be found using `find_package()`.
- Generate the "C" interface project using **commsdsl2c**. It generates **CMakeLists.txt** file allowing the generated project being built
  separately.
- Build the project generated by the **commsdsl2c** setting relevant pathes to find its dependencies.

## Produced Output

- **include** folder - Contains header files with the "C" interface. All header files with reside in `c_cc` subfolder.
- **cc_c** folder - Contains source files with implemented "C" interface functions.
- **CMakeLists.txt** - CMake project definition file allowing output to be built as a separate CMake project.

## Generated CMake Project
As it was mentioned above, the output of the **commsdsl2c**
(like any other [commsdsl](https://github.com/commschamp/commsdsl) code generator) contains **CMakeLists.txt**.
It can be used to build it as a separate cmake project.

Please open the generated **CMakeLists.txt** and see the build configuration.

Note that the dependencies for the generated project are [COMMS Library](https://github.com/commschamp/comms) and
the protocol definition project generated by the **commsdsl2comms**.

There are 2 ways to bring these dependencies in. Both of them are headers only libraries.

- The relevant include directories can be brought in using **OPT_EXTRA_INCLUDE_DIRS** cmake variable.
- In case the dependency projects are built and installed, then they can be brought in using the standard cmake way of specifying relevant installation paths with
  the **CMAKE_PREFIX_PATH** variable, and enabling the usage of the `find_package()` with the
  **OPT_FIND_COMMS** and **OPT_FIND_PROTOCOL** options enabled.

## Class Naming
The C++ scope of the class is flattened by replacing `::` with `_`.

For example:
```xml
<shema name="my_prot">
    <fields>
        <int name="F1" type="uint32" />
    </fields>

    <message name="Msg1" id="1">
        <ref field="F1" />
    </message>
</schema>
```

The generated "C" interface handlers are prefixed with the protocol name namespace. It means that the
types for the entities above will be `my_prot_field_F1` for the global field `F1` and `my_prot_message_Msg1` for the
message `Msg1`.

The original protocol definition classes (generated by the **commsdsl2comms**) reside in the
`include/my_prot/field/F1.h` and `include/my_prot/message/Msg1`.

To differentiate between the include paths of the original C++ class and the wrapper, the **commsdsl2c** adds
top level `cc_c` folder, so the generated handles definition files reside in
`include/cc_c/my_prot/field/F1.h` and `include/cc_c/my_prot/message/Msg1.h` respectively.

The handles are just forward declared structs to allow their usage in the generated functions:
```c
typedef struct my_prot_message_Msg1_ my_prot_message_Msg1;
```

The implemented functions reside in the source files
`cc_c/my_prot/field/F1.cpp` and `cc_c/my_prot/message/Msg1.cpp` respectively.

## Member Function Naming
All the member functions of the classes generated by the **commsdsl2comms** are translated into "C" functions
with a full [class name](#class-naming) prefix. For example function to acquire access to the `F1` field member of the `Msg1` message
in the example above will be:
```c
my_prot_message_Msg1Fields_F1* my_prot_message_Msg1_field_f1(my_prot_message_Msg1* msg);
```
Note that all "member functions" will accept a handle to their object as their first parameter.

## Message Handling
Following the same convention as with the protocol generated by the **commsdsl2comms** (unless the
protocol definition defines its own `<interface>`) the default interface handle is named `<prot_namespace>_Message` and
resides in `include/cc_c/<prot_namespace>/Message.h`.

The actual interface definition is fully polymorphic defined using appropriate options and resides in the `cc_c/<prot_namespace>/Message_comms.h`
```cpp
class my_prot_MsgHandler_comms;
class my_prot_Message_comms : public
    ::my_prot::Message<
        comms::option::app::IdInfoInterface,
        comms::option::app::ReadIterator<const uint8_t*>,
        comms::option::app::WriteIterator<uint8_t*>,
        comms::option::app::ValidCheckInterface,
        comms::option::app::LengthInfoInterface,
        comms::option::app::RefreshInterface,
        comms::option::app::NameInterface,
        comms::option::app::Handler<my_prot_MsgHandler_comms>
    >
{
};
```

The options are described in details in the [tutorial1](https://github.com/commschamp/cc_tutorial/tree/master/tutorials/tutorial1).

The `comms::option::app::Handler` option introduces `dispatch()` member function, which allows polymorphic dispatch to the handler object.

The handling struct `<prot_namespace>_MsgHandler` is defined in `include/cc_c/<prot_namespace>/MsgHandler.h`. It contains
pointers to multiple handling functions which can be set in the client "C" code. Due to the fact that
"C" can NOT have overloaded member functions with the same name, the name of the handling function contains
the message handle name as well:
```c
typedef struct
{
    void (*handle_my_prot_message_Msg1)(struct my_prot_message_Msg1_* msg, void* userData);
    void (*handle_my_prot_message_Msg2)(struct my_prot_message_Msg2_* msg, void* userData);
    ...
    void (*handle_my_prot_Message)(struct my_prot_Message_* msg, void* userData);
} my_prot_MsgHandler;
```
By default if relevant `handle_<prot_namespace>_message_X()` pointer to handling function is not set (equals to **NULL**)
the interface handling function `handle_<prot_namespace>_Message()` (if set) will be invoked.

The interface processing functions will contain a "dispatch" functionality, which can be used to dispatch message object to appropriate handling function.
```c
void my_prot_Message_dispatch(my_prot_Message* msg, my_prot_MsgHandler* handler, void* userData);
```

## Working with Frames
Every protocol definition is expected to define its framing:
```xml
<shema name="my_prot">
    <frame name="Frame">
        ...
    </frame>
</schema>
```
The "C" interface definition will reside in `include/cc_c/<prot_namespace>/frame/<frame_name>.h`
and will look like this:
```c
typedef struct my_prot_frame_Frame_ my_prot_frame_Frame;

my_prot_frame_Frame* my_prot_frame_Frame_alloc(void);
void my_prot_frame_Frame_free(my_prot_frame_Frame* frame);
my_prot_Message* my_prot_frame_Frame_createMsg(my_prot_frame_Frame* frame, my_prot_MsgId msgId, unsigned idx);
void my_prot_frame_Frame_deleteMsg(my_prot_Message* msg);
size_t my_prot_frame_Frame_processInputData(my_prot_frame_Frame* frame, const uint8_t* buf, size_t bufSize, my_prot_MsgHandler* handler, void* userData);

typedef struct
{
    ...
} my_prot_frame_Frame_FrameValues;

size_t my_prot_frame_Frame_processInputDataSingleMsg(
    my_prot_frame_Frame* frame,
    const uint8_t* buf,
    size_t bufSize,
    my_prot_MsgHandler* handler,
    void* userData,
    my_prot_frame_Frame_FrameValues* frameValues);

my_prot_ErrorStatus my_prot_frame_Frame_writeMessage(my_prot_frame_Frame* frame, const my_prot_Message* msg, uint8_t* buf, size_t* bufLen);
size_t my_prot_frame_Frame_messageLength(const my_prot_frame_Frame* frame, const my_prot_Message* msg);
```
This is the primary integration point between the protocol library and the client code. The raw data received over the
I/O link is fed into the frame handling function(s) to create and process the decoded messages. The frame functionality
is also used to serialize the created message object before the raw data output is sent back over the
I/O link.

The framing object needs to be dynamically allocated via `<prot_namespace>_frame_<frame_name>_alloc()` and freed via `<prot_namespace>_frame_<frame_name>_free()` when no longer needed.

The `<prot_namespace>_frame_<frame_name>_processInputData()` will process bytes in the input buffer, decode them, create appropriate message objects and dispatch the latter to the
provided handler. The function returns number of consumed bytes in the buffer. It's up the the client code caller to
manage the input buffer and delete consumed bytes from it. In case the function returns amount of consumed bytes less than
held by the buffer, it means that framing of the last message is incomplete (not all bytes received). The remaining bytes
need to be preserved and then re-process attempted when new raw data comes in. Note that the message object dispatched to the handler is a temporary one which
will be deleted right after the function returns, the caller mustn't preserve a pointer to it in its inner data structures.

The `<prot_namespace>_frame_<frame_name>_processInputDataSingleMsg()` is very similar to `<prot_namespace>_frame_<frame_name>_processInputData()`, but allows creation and handling only one message object
at a time. It also provides an opportunity (via `frameValues` output parameter) to get and analyze the message frame constructing values.
In cases the function invocation returns `0` when the input buffer is not empty, then it means there are not enough bytes
to properly construct the message. The remaining bytes
need to be preserved and then re-process attempted when new raw data comes in.

The `<prot_namespace>_frame_<frame_name>_writeMessage()` needs to be used to frame and serialize any message object. The serialized message bytes are
written to the buffer. The `bufLen` parameter is both input (amount of available bytes in the buffer) and output (amount of bytes written);

The `<prot_namespace>_frame_<frame_name>_messageLength()` can be used to inquire about required output buffer size to fit the serialized message.

## Sending Messages
Every message definition will define dynamic memory allocation and deletion functions:
```c
my_prot_message_Msg1* my_prot_message_Msg1_alloc(void);
void my_prot_message_Msg1_free(my_prot_message_Msg1* msg);
```

Once allocated it is possible to acquire access to its fields and set their values:
```c
// Allocate frame object
my_prot_frame_Frame* frame = my_prot_frame_Frame_alloc()

// Allocate message object and update its inner fields
my_prot_message_Msg1* msg1 = my_prot_message_Msg1_alloc();
my_prot_message_Msg1Fields_F1* f1 = my_prot_message_Msg1_field_f1(msg1);
my_prot_message_Msg1Fields_F1_setValue(f1, 123);

// Send message
my_prot_Message* interface = my_prot_message_Msg1_toInterface(msg1);
size_t bufLen = my_prot_frame_Frame_messageLength(frame, interface)
uint8_t* buf = malloc(bufLen);
my_prot_ErrorStatus es = my_prot_frame_Frame_writeMessage(frame, interface, buf, &bufLen);
if (my_prot_ErrorStatus != my_prot_ErrorStatus_Success) {
    ... // Report error
}
else {
    ... // Send buffer contents over I/O link
}

// Delete allocated objects when no longer needed
free(buf);
my_prot_message_Msg1_free(msg1);
my_prot_frame_Frame_free(frame);
```
Note that the frame handling functions receive message object via the interface handle. Every message provides relevant conversion functions:
```c
my_prot_Message* my_prot_message_Msg1_toInterface(my_prot_message_Msg1* msg);
my_prot_message_Msg1* my_prot_message_Msg1_fromInterface(my_prot_Message* msg);
```

Another way to allocate message object is to use the frame:
```c
my_prot_Message* interface = my_prot_frame_Frame_createMsg(frame, my_prot_MsgId_M1, 0);
my_prot_message_Msg1* msg1 = my_prot_message_Msg1_fromInterface(interface);
...
// Delete message object when no longer needed
my_prot_frame_Frame_deleteMsg(interface);
```
Note that the message object must be deleted using `<prot_namespace>_frame_<frame_name>_deleteMsg()` when allocated via `<prot_namespace>_frame_<frame_name>_createMsg()`,
while `<prot_namespace>_message_<msg_name>_free()` is used only when allocated with `<prot_namespace>_message_<msg_name>_alloc()`.

## Working with Fields
An access to the message fields and their values is very similar to the one used when working directly with C++ code.
Every message has `*_field_x()` access function(s). The field's functions will have
`*_getValue()` and `*_setValue()` to get / set the field's value.
```c
my_prot_message_Msg1Fields_F1* f1 = my_prot_message_Msg1_field_f1(msg1);
my_prot_message_Msg1Fields_F1_setValue(f1, 123);
```

## Working with &lt;ref&gt; Fields
It is quite common to define field in the global space and then `<ref>`-erence it as the
member field of the `<message>`.
```xml
<shema name="my_prot">
    <fields>
        <int name="F1" type="uint8" />
    </fields>
    <message name="Msg1" id="1">
        <ref field="F1" />
    </message>
</schema>
```
The `<ref>` fields don't have any direct get/set functionality. There is a need to acquire a handle for the referenced field.
```
my_prot_message_Msg1Fields_F1* f1 = my_prot_message_Msg1_field_f1(msg1);
my_prot_field_F1* actF1 = my_prot_message_Msg1Fields_F1_ref(my_prot_message_Msg1Fields_F1* f1)
my_prot_field_F1_setValue(actF1, 123);
```

## Working with &lt;string&gt; Fields
When it comes to `<string>` fields, the get / set value functions are a bit different:
```c
size_t my_prot_field_S1_valueSize(const my_prot_field_S1* field);
size_t my_prot_field_S1_getValue(const my_prot_field_S1* field, char* buf, size_t bufSize);
void my_prot_field_S1_setValue(my_prot_field_S1* field, const char* buf, size_t bufSize);
```
To get the string value length the `*_valueSize()` function can be used and then getting the value is just copying it to output buffer:
```c
char str[256] = {0};
size_t strLen = my_prot_field_S1_getValue(field, str, sizeof(str));
...
```

## Working with &lt;data&gt; Fields
Get / set of the `<data>` field value is very similar to the `<string>` one:
```c
size_t my_prot_field_D1_valueSize(const my_prot_field_D1* field);
size_t my_prot_field_D1_getValue(const my_prot_field_D1* field, uint8_t* buf, size_t bufSize);
void my_prot_field_D1_setValue(my_prot_field_D1* field, const uint8_t* buf, size_t bufSize);
```

## Working with &lt;list&gt; Fields
The `<list>` field operates on a sequence of other fields. The get / set functionality here is a bit different:
```c
// Acquire access to the existing element field by its index
my_prot_field_L1Members_Elem* my_prot_field_L1_at(my_prot_field_L1* field, size_t idx);

// Resize the inner storage to fit specified amount of elements.
void my_prot_field_L1_resize(my_prot_field_L1* field, size_t count);

// Retrieve amount of currently stored elements.
size_t my_prot_field_L1_count(const my_prot_field_L1* field);

// Insert new element at specified position.
my_prot_field_L1Members_Elem* my_prot_field_L1_insert(my_prot_field_L1* field, size_t idx);

// Append new element at the end.
my_prot_field_L1Members_Elem* my_prot_field_L1_append(my_prot_field_L1* field);

// Remove element at specified position.
bool my_prot_field_L1_remove(my_prot_field_L1* field, size_t idx);
```

## Working with &lt;variant&gt; Fields
Just like working with regular C++ code generated by the **commsdsl2comms**, the "C" interface
functions provide `*_initField_<mem_name>()` and `*_accessField_<mem_name>()` to initialize and access when already initialized specific
member.

Similar to dispatching message object to appropriate handling function, the member fields of the `<vairant>` are also dispatchable to their
appropriate handling functions:
```c
// Handler with handling functions for the members
typedef struct
{
    void (*handle_p1)(my_prot_field_Variant1Members_P1* field);
    void (*handle_p2)(my_prot_field_Variant1Members_P2* field);
} my_prot_field_Variant1_MemHandler;

// Dispatch the currently selected member into its appropriate handling function.
void my_prot_field_Variant1_currFieldExec(my_prot_field_Variant1* field, my_prot_field_Variant1_MemHandler* handler);
```

## Working with Units
Working with units in the C++ code is straightforward, just use appropriate function from the
[comms::units](https://commschamp.github.io/comms_doc/namespacecomms_1_1units.html) namespace.

For example, let's assume there is a field containing 1/10 of the millimeters.
```xml
<shema name="my_prot">
    <fields>
        <int name="Distance" type="int32" units="mm" scaling="1/10" displayDecimals="1" />
    </fields>
    <message name="Msg1" id="1">
        <ref field="Distance" />
    </message>
</schema>
```
In case the application code works with meters rather millimeters, the relevant code would like like:
```cpp
comms::units::setMeters(msg1.field_distance(), 1.123)
```
or
```cpp
auto distInMeters = comms::units::getMeters<double>(msg1.field_distance());
```
When working with "C" interface there is a need to explicitly provide the wrapping
functions for the relevant field. The **commsdsl2c** code generator provides
a way to inject the custom code the same way as it does **commmsdsl2comms**.

In the case described above we would like to add functions allowing to get / set meters
to the fields value. To achieve that we need to create appropriate file injecting extra code to the field files:

include/cc_c/my_prot/field/Distance.h.append
```c
double my_prot_field_Distance_getMeters(const my_prot_field_Distance* field);
void my_prot_field_Distance_setMeters(my_prot_field_Distance* field, double val);
```

cc_c/my_prot/field/Distance.cpp.append
```cpp
double my_prot_field_Distance_getMeters(const my_prot_field_Distance* field)
{
    return comms::units::getMeters<double>(*fromFieldHandle(field));
}

void my_prot_field_Distance_setMeters(my_prot_field_Distance* field, double val)
{
    comms::untils::setMeters(*fromFieldHandle(field), val);
}
```

Note that there might be a need to add extra include statement in `.inc` file:

cc_c/my_prot/field/Distance.h.inc
```cpp
#include "comms/units.h"
```

