# WebAssembly Support

The [CommsChampion Ecosystem](https://commschamp.github.io/) is mostly about C++ and embedded systems.
The [emscripten](https://emscripten.org) toolchain allows compilation of the source code to WebAssembly as
well as generating javascript bindings.

The generation of the [emscripten](https://emscripten.org) bindings code is performed using **commsdsl2emscripten** code
generator, please make sure its build is enabled by using appropriate cmake [options](../CMakeLists.txt).


## Build Order

- Build and install [COMMS Library](https://github.com/commschamp/comms) project.
- Generate the protocol definition files using **commsdsl2comms**.
- Properly build and install the generated protocol definition project. It will generate appropriate cmake config
  file allowing the protocol headers only library to be found using `find_package()`.
- Generate the emscripten bindings using **commsdsl2emscripten**. It generates **CMakeLists.txt** file allowing the generated project being built
  separately.
- Build the project generated by the **commsdsl2emscripten** setting relevant toolchain environment.


## Produced Output

- **include** folder - Contains header files with the declaration of the wrapper C++ classes, bindings for which are expected to be generated.
- **cc_emscripten** folder - Contains source files with [emscripten](https://emscripten.org) bindings as well as some code snippets relevant for
  the wrapper classes defined in the **include** folder.
- **CMakeLists.txt** - CMake project definition file allowing output to be built as a separate CMake project.


## Generated CMake Project
As it was mentioned above, the output of the **commsdsl2emscripten**
(like any other [commsdsl](https://github.com/commschamp/commsdsl) code generator) contains **CMakeLists.txt**.
It can be used to build it as a separate cmake project.

Please open the generated **CMakeLists.txt** and see the build configuration. It contains the following condition:
```
if (NOT EMSCRIPTEN)
    message (FATAL_ERROR "Expected to be wrapped in emcmake")
endif ()
```

This condition requires cmake invocation being wrapped in `emcmake` utility provided by the `emscripten` toolchain.
```
emcmake cmake -DCMAKE_BUILD_TYPE=Release ...
```
Such invocation configures the necessary build environment.

Also note that the dependencies for the generated project are [COMMS Library](https://github.com/commschamp/comms) and
the protocol definition project generated by the **commsdsl2comms**.

There are 2 ways to bring these dependencies in. Both of them are headers only libraries.

- The relevant include directories can be brought in using **OPT_EXTRA_INCLUDE_DIRS** cmake variable.
- In case the dependency projects are built and installed using the same emscripten toolchain, then the
  dependency projects can be brought it using the standard cmake way of specifying relevant installation paths with
  the **CMAKE_PREFIX_PATH** variable, and enabling the usage of the `find_package()` with the
  **OPT_FIND_COMMS** and **OPT_FIND_PROTOCOL** options enabled.

# Interacting with Protocol Code
Please read through the available [Interacting with code](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html)
documentation page of the [emscripten](https://emscripten.org) toolchain. It contains information of how
to call the compiled functions and/or load the module if you're
[using nodejs](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-an-api-written-in-c-c-from-nodejs).

## Class Naming
The C++ scope of the class is flattened by replacing `::` with `_` and omitting the top level namespace by default.

For example:
```xml
<shema name="my_prot">
    <fields>
        <int name="F1" type="uint32" />
    </fields>

    <message name="Msg1" id="1">
        <ref field="F1" />
    </message>
</schema>
```

The generated classes are not prefixed with the protocol name namespace. It means that the
types for the entities above will be `field_F1` for the global field `F1` and `message_Msg1` for the
message `Msg1`.

The original protocol definition classes (generated by the **commsdsl2comms**) reside in the
`include/my_prot/field/F1.h` and `include/my_prot/message/Msg1`.

To differentiate between the include paths of the original class and the wrapper, the **commsdsl2emscripten** adds
top level `cc_empscripten` folder, so the generated class definition files reside in
`include/cc_emscripten/my_prot/field/F1.h` and `include/cc_empscripten/my_prot/message/Msg1.h` respectively.

The bindings definitions reside in the source files
`cc_emscripten/my_prot/field/F1.cpp` and `cc_empscripten/my_prot/message/Msg1.cpp` respectively.

When there are [multiple different schema names](https://commschamp.github.io/commsdsl_spec/#intro-multiple-schemas) in
use, then all the generated classes are prefixed with their schema (protocol) name automatically to differentiate between them.

Also, the **commsdsl2emscripten** code generator has the `force-main-ns-in-names` command line option forcing the main namespace
prefixing of the generated classes.

## Understanding Available Bindings
In order to understand what binding functionality is provided and what functions are available to be called from
the javascript code it is essential to read through the [embind](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html)
documentation page before opening the relevant generated .h/.cpp file(s) and reading through the generated code.

## Raw Data Buffer
When dealing with raw data buffers, the binding C++ classes expect to work with `DataBuf` class, which
is an alias to `std::vector<std::uint8_t>`. It is defined in the `include/cc_empscripten/<prot_namespace>/DataBuf.h`
header file.

The generated `cc_emscripten/<prot_namespace>/DataBuf.cpp` file contains bindings for this class.
The bindings are generated using the following code:
```cpp
emscripten::register_vector<std::uint8_t>("DataBuf");
```
The `register_vector` function is provided by the [emscripten](https://emscripten.org) toolchain. Unfortunately the
[embind](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html) documentation doesn't provide
any real information of what functionality is really available. To understand it there is a need to open the
provided by the toolchain `bind.h` file (usually resides in the `/usr/share/emscripten/system/include/emscripten/` folder) and
read the relevant code.

```cpp
namespace internal {

template<typename VectorType>
struct VectorAccess {
    static val get(const VectorType& v, typename VectorType::size_type index) {...}
    static bool set(VectorType& v, typename VectorType::size_type index, const typename VectorType::value_type& value) {...}
};

} // end namespace internal

template<typename T>
class_<std::vector<T>> register_vector(const char* name) {
    typedef std::vector<T> VecType;

    void (VecType::*push_back)(const T&) = &VecType::push_back;
    void (VecType::*resize)(const size_t, const T&) = &VecType::resize;
    size_t (VecType::*size)() const = &VecType::size;
    return class_<std::vector<T>>(name)
        .template constructor<>()
        .function("push_back", push_back)
        .function("resize", resize)
        .function("size", size)
        .function("get", &internal::VectorAccess<VecType>::get)
        .function("set", &internal::VectorAccess<VecType>::set)
        ;
}
```
Please pay attention to the following:

- The `resize()` member function takes 2 parameters. The second one is the default value to be assigned to each cell when the size need to grow.
- The access to the cells is performed using `get()` and `set()` member functions, which are implemented as static ones inside the helper `VectorAccess` class.
  There is no usual `operator[]` available.
- There are no other convenience functions like `empty()`, `pop_back()`, `clear()`, etc... Such extra functionality will have to be implemented using the available bindings.

The code generated by the **commsdsl2emscripten** provides extra convenience stand alone functions:
```
emscripten::val dataBufMemoryView(const DataBuf* buf);
DataBuf jsArrayToDataBuf(const emscripten::val& buf);
```

The `dataBufMemoryView()` provides a [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) **VIEW** on the original
`DataBuf`.
```js
var dataBuf = new my_prot.DataBuf();
... // Populate dataBuf
var arrayView = my_prot.dataBufMemoryView(dataBuf);
... // JS code on Uint8Array.
dataBuf.delete(); // Destruction of the dataBuf allowed after only after use of arrayView is complete
```

**IMPORTANT**: The `Uint8Array` returned by the `dataBufMemoryView()` function is just a **VIEW** on the original buffer, which must be preserved during the
operations on the `Uint8Array`.

The `jsArrayToDataBuf()` provides a convenience function of converting java script arrays to the `DataBuf`. **NOTE** that the `DataBuf` object is
returned by value. It means that the [emscripten](https://emscripten.org) bindings code will perform dynamic memory allocation, which will need
to be explicitly deleted later. See [Memory Management](#memory-management) section below for more details.

## Message Handling
Following the same convention as with the protocol generated by the **commsdsl2comms** (unless the
protocol definition defines its own `<interface>`) the default interface class is named `Message` and
resides in `include/cc_emscripten/<prot_namespace>/Message.h`. The defined interface is fully polymorphic defined using
appropriate options:
```cpp
class MsgHandler;
class Message : public
    test4::Message<
        comms::option::app::ReadIterator<DataBuf::const_iterator>,
        comms::option::app::WriteIterator<std::back_insert_iterator<DataBuf> >,
        comms::option::app::IdInfoInterface,
        comms::option::app::ValidCheckInterface,
        comms::option::app::LengthInfoInterface,
        comms::option::app::RefreshInterface,
        comms::option::app::NameInterface,
        comms::option::app::Handler<MsgHandler>
    >
{
    ...
};
```

The options are described in details in the [tutorial1](https://github.com/commschamp/cc_tutorial/tree/master/tutorials/tutorial1).

The `comms::option::app::Handler` option introduces `dispatch()` member function, which allows polymorphic dispatch to the handler object.

The handling class `MsgHandler` is defined in `include/cc_emscripten/<prot_namespace>/MsgHandler.h`. It defines
multiple **virtual** handling functions which can be overridden in the javascript code. Due to the fact that
javascript can NOT have overloaded member functions with the same name, the name of the handling function contains
the message class name as well:
```cpp
class MsgHandler
{
public:
    MsgHandler() = default;
    virtual ~MsgHandler();

    virtual void handle_message_Msg1(message_Msg1* msg);
    virtual void handle_message_Msg2(message_Msg2* msg);
    ...

    virtual void handle_Message(Message* msg);
};
```
By default every `handle_message_X()` calls the interface invocation `handle_Message()`, which by default
does nothing.

The emscripten documentation contains an [example](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html#extend-example) of
how to extend the C++ class in javascript and override its functions. In case of `MsgHandler` it call look something like that:
```js
function allocHandler(my_prot)
{
    var DerivedHandler = my_prot.MsgHandler.extend("MsgHandler", {
        handle_message_Msg1: function(msg) {
            ... // Handle Msg1
        },
        handle_message_Msg2: function(msg) {
            ... // Handle Msg2
        },
        handle_Message: function(msg) {
            ... // Handle generic message that doesn't have its handling function
        }
    });

    return new DerivedHandler; // Requires explicit delete later
}
```

## Working with Frames
Every protocol definition is expected to define its framing:
```xml
<shema name="my_prot">
    <frame name="ProtFrame">
        ...
    </frame>
</schema>
```
The wrapping class interface definition will reside in `include/cc_emscripten/my_prot/frame/ProtFrame.h`
and look like this:
```cpp
class frame_ProtFrame_AllFields
{
   ...
};

class frame_ProtFrame
{
public:
    ...

    std::size_t processInputData(const DataBuf& buf, MsgHandler& handler);
    std::size_t processInputJsArray(const emscripten::val& buf, MsgHandler& handler);
    std::size_t processInputDataSingleMsg(const DataBuf& buf, MsgHandler& handler, frame_Frame_AllFields* allFields = nullptr);
    std::size_t processInputJsArraySingleMsg(const emscripten::val& buf, MsgHandler& handler, frame_Frame_AllFields* allFields = nullptr);
    comms::ErrorStatus writeMessage(const Message& msg, DataBuf& buf);
};
```
This is the primary integration point between the protocol library and the client code. The raw data received over the
I/O link is fed into the frame object to create and process the decoded messages. The frame functionality
is also used to serialize the created message object before the raw data output is sent back over the
I/O link.

The `processInputData()` will process bytes in the input buffer, decode them, create appropriate message objects and dispatch the latter to the
provided handler. The function returns number of consumed bytes in the buffer. It's up the the client code caller to
manage the input buffer and delete consumed bytes from it. In case the function returns amount of consumed bytes less than
held by the buffer, it means that framing of the last message is incomplete (not all bytes received). The remaining bytes
need to be preserved and then re-process attempted when new raw data comes in.

The `processInputJsArray()` is very similar to the `processInputData()`. The only difference that it expects
a javascript array (such as `Uint8Array`) to be passed as the first parameter instead of the `DataBuf`.

The `processInputDataSingleMsg()` is very similar to `processInputData()`, but allows creation and handling only one message object
at a time. It also provides an opportunity (via `allFields` output parameter) to get and analyze the message frame constructing fields.
In cases the function invocation returns `0` when the input buffer is not empty, then it means there are not enough bytes
to properly construct the message. The remaining bytes
need to be preserved and then re-process attempted when new raw data comes in.

The `processInputJsArraySingleMsg()` is very similar to the `processInputDataSingleMsg()`. The only difference that it expects
a javascript array (such as `Uint8Array`) to be passed as the first parameter instead of the `DataBuf`.

The `writeMessage()` needs to be used to frame and serialize any message object. The serialized message bytes are
appended to the buffer.

## Memory Management
If you haven't done so yet, please read through the
[Memory management](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html#memory-management)
section of the emscripten documentation. It specifies that every instance of the bound C++ class needs to be explicitly
deleted. The binding code provides `delete()` member function for it.
```js
var frame = new my_prot.frame_ProtFrame();
var msg1 = new my_prot.message_Msg1().
var outputBuf = new my_prot.DataBuf();
... // Populate msg1 fields
var es = frame.writeMessage(msg1, outputBuf);
var jsOutputBuf = my_prot.dataBufMemoryView(outputBuf);
... // Send jsOutputBuf
outputBuf.delete();
msg1.delete();
frame.delete();
```

Also, as the rule of thumb: Do **NOT** store references to the objects you have not **explicitly** created. For example the
invocation of the frame's `processInputData()` results in creation of the message object, then dispatching it to the
handler. Once the handling function returns, the allocated message object is deleted / destructed by C++ code. If such object
needs to be stored, use explicit copy-construction.
```js
function allocHandler(my_prot)
{
    var DerivedHandler = my_prot.MsgHandler.extend("MsgHandler", {
        handle_message_Msg1: function(msg) {
            this.msg1 = new my_prot.message_Msg1(msg); // Copy construction
            ...
        },

    });

    return new DerivedHandler; // Requires explicit delete later
}
```
Note that the copy constructed object will also require explicit `delete()` invocation when it's no longer needed.

Extra care is required when working with a reference to a data member. It mustn't be accessed after
the reference to the holding object is invalidated.
```js
var msg = new my_prot.message_Msg1();
var f1 = msg.field_f1();       // Reference to a member field
msg.delete();
f1.setValue(1)                 // Access to invalid memory
```

Another thing is worth being aware of is returning something **by value**. If a C/C++ function returns something **by value** and
it's **NOT** one of the emscripten [built-in](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions)
types, then dynamic memory allocation is used and explicit `delete()` invocation will be required. For example
usage of the `jsArrayToDataBuf()` function mentioned above.
```js
var jsArray = new Uint8Array([...]);
var dataBuf = my_prot.jsArrayToDataBuf(jsArray); // Dynamic memory allocation is here
... // Do something with dataBuf
dataBuf.delete(); // No longer needed
```

Note that `std::string` is listed among the **built-in** types. It means no explicit `delete()` invocation on strings is required.
```js
var msg1 = new my_prot.message_Msg1();
var msg1Name = msg1.name(); // returns std::string by value, no deletion is required
console.log(msg1Name);
msg1.delete();
```
## Working with Fields
An access to the message fields and their values is very similar to the one used when working directly with C++ code.
Every message has `field_x()` accessor function(s) for the member field object(s), and the latter have
`getValue()` and `setValue()` member functions to get / set the field's value.

For example:
```xml
<shema name="my_prot">
    <message name="Msg1" id="1">
        <int name="F1" type="uint8" />
    </message>
    <frame name="ProtFrame">
        ...
    </frame>
</schema>
```
The javascript code may look like this:
```js
var msg1 = new my_prot.message_Msg1();
msg1.field_f1().setValue(123);

var buf = new my_prot.DataBuf();
var es = frame.writeMessage(msg1, buf);
... // Send raw data from buffer over I/O link
buf.delete();
msg1.delete();
```

Some simple fields, like `<int>`, `<enum>`, or `<set>` define
[property](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html#classes)
in their bindings:
```cpp
emscripten::class_<field_F1>("field_F1")
    .constructor<>()
    .constructor<const field_F1&>()
    .property("value", &field_F1::getValue, &field_F1::setValue)
    .function("getValue", &field_F1::getValue)
    .function("setValue", &field_F1::setValue)
    ...
    ;
```
It means in addition to `getValue()` and `setValue()` functions, the stored field's value can
be accessed via `value` property (as if data member).
```cpp
msg1.field_f1().value = 123;
var f1Val = msg1.field_f1().value;
```

## Working with &lt;ref&gt; Fields
It is quite common to define field in the global space and then `<ref>`-erence it as the
member field of the `<message>`.
```xml
<shema name="my_prot">
    <fields>
        <int name="F1" type="uint8" />
    </fields>
    <message name="Msg1" id="1">
        <ref field="F1" />
    </message>
</schema>
```
When working with C++ there is a direct inheritance relationship between generated
`my_prot::field::F1` and `my_prot::message::Msg1Fields::F1` and the member functions and types
of the first can be used when working with the second. However, this is not the
case with the generated wrapper classes:

- `field_F1` --> `my_prot::field::F1`
- `message_Msg1Fields_F1` --> `my_prot::message::Msg1Fields::F1` --> `my_prot::field::F1`

It is visible there is no direct inheritance relationship between `field_F1` and `message_Msg1Fields_F1`.
As the result the member functions and types of the first cannot be seamlessly used when working
with the second. To workaround this problem every wrapping class of the `<ref>` field has `ref()` member
function to do the explicit conversion to the global field type:
```js
var msg1 = new my_prot.message_Msg1();
msg1.field_f1().ref().setValue(123);
...
```

## Working with &lt;enum&gt; Fields
The C++ class of the `<enum>` field (generated by the **commsdsl2comms**) defines inner `ValueType` enum type.
The emscripten binding code (generated by the **commsdsl2emscripten**) names the enum by appending `_ValueType` suffix to
the field class name. For example:
```xml
<shema name="my_prot">
    <fields>
        <enum name="F1" type="uint8">
            <validValue name="V1" val="0" />
            <validValue name="V2" val="1" />
        </enum>
    </fields>
</schema>
```
The generated bindings code look like this:
```cpp
emscripten::enum_<field_F1::ValueType>("field_F1_ValueType")
    .value("V1", field_F1::ValueType::V1)
    .value("V2", field_F1::ValueType::V2)
    .value("ValuesLimit", field_F1::ValueType::ValuesLimit)
    ;
```
The relevant javascript code may look like this:
```js
msg.field_f1().setValue(my_prot.field_F1_ValueType.V2);
```

It looks like emscripten implements enum values not as constants, but as empty javascript objects. In order to be able to
convert the enum values to numeric constants the wrapping field class adds several new functions that could be used in javascript code:
```cpp
class field_F1 : public my_prot::field::F1<>
{
public:
    static typename std::underlying_type<ValueType>::type asConstant(ValueType val) { ... }
    typename std::underlying_type<ValueType>::type getValueConstant() const { ... }
    void setValueConstant(typename std::underlying_type<ValueType>::type val) { ... }
    ...
};
```

## Working with &lt;string&gt; Fields
As was mentioned earlier, the `std::string` is one of the
[built-in](https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions)
types of the emscripten. It insures seamless conversion between javascript and C++ strings.

For example:
```xml
<shema name="my_prot">
    <message name="Msg1" id="1">
        <string name="F1" />
    </message>
</schema>
```
The generated field wrapper class `message_Msg1Fields_F1` will inherit its `ValueType` to be
`std::string`.

The javascript code may use the relevant strings directly:
```js
var msg = new my_prot.message_Msg1();
msg.field_f1().setValue("hello");       // Expects const std::string&
console.log(msg.field_f1().getValue()); // Returns const std::string&
...
```

## Working with &lt;data&gt; Fields
The wrapping class of the `<data>` field inherits its `ValueType` definition, which is `std::vector<std::uint8_t>`.
It is the same as the [DataBuf](#raw-data-buffer) described earlier. The client code
is expected to work with the `DataBuf` object and its provided interface when dealing with the value of the
relevant `<data>` field.

## Working with &lt;list&gt; Fields
The `ValueType` of every `<list>` field is defined to be `std::vector` of the element field. The
generated code (for global referenced element field F1) provide the following functions and bindings:
```cpp
void field_F1_Vector_resize(std::vector<field_F1>& vec, std::size_t count) { ... }
std::size_t field_F1_Vector_size(const std::vector<field_F1>& vec) { ... }
field_F1* field_F1_Vector_at(std::vector<field_F1>& vec, std::size_t idx) { ... }

emscripten::class_<std::vector<field_F1> >("field_F1_Vector")
    .constructor<>()
    .constructor<const std::vector<field_F1_Vector>&>()
    .function("resize", &field_F1_Vector_resize)
    .function("size", &field_F1_Vector_size)
    .function("at", &field_F1_Vector_at, emscripten::allow_raw_pointers());
```
It means that there only 3 operations for the storage vector of the `<list>` field:

- `resize()` - to resize the vector
- `size()` - inquire the size of the vector
- `at()` - access the element in the vector

Also note that the generated wrapper class for the `<list>` field will have a `value()`
member function to access the storage by pointer.

For example:
```xml
<shema name="my_prot">
    <message name="Msg1" id="1">
        <list name="F1">
            <element>
                <int name="commsdsl::gen::GenElem" type="uint32" />
            </element>
            <countPrefix>
                <int name="Count" type="uint8" />
            </countPrefix>
        </list>
    </message>
</schema>
```
The javascript code may look like this:
```js
var msg = new my_prot.message_Msg1();
var f1Vec = msg.field_f1().value();
f1Vec.resize(2);
f1Vec.at(0).setValue(123);
f1Vec.at(1).setValue(321);
```

## Working with &lt;variant&gt; Fields
Just like working with regular C++ code generated by the **commsdsl2comms**, the wrapping
C++ declaration class provides
`initField_X()` and `accessField_X()` to initialize and access when already initialized specific
member. The wrapping class also provides `currentFieldExec()` to be able to determine
the actual held member field and dispatch it to the right handling function:
```cpp
struct field_Variant1_Handler
{
    virtual ~field_Variant1_Handler();

    virtual void handle_p1(field_Variant1Members_P1* field);
    virtual void handle_p2(field_Variant1Members_P2* field);
};

class field_Variant1
{
public:
    field_Variant1Members_P1* initField_p1();
    field_Variant1Members_P1* accessField_p1();

    field_Variant1Members_P2* initField_p2();
    field_Variant1Members_P2* accessField_p2();
    ...
    void currentFieldExec(field_Variant1_Handler& handler);
    ...
};
```
The relevant `X_Handler` class can be extended in the javascript code and its handling functions can be overridden, just like it
is done with the [message handling](#message-handling).

## Working with Units
Working with units in the C++ code is straightforward, just use appropriate function from the
[comms::units](https://commschamp.github.io/comms_doc/namespacecomms_1_1units.html) namespace.

For example, let's assume there is a field containing 1/10 of the millimeters.
```xml
<shema name="my_prot">
    <fields>
        <int name="Distance" type="int32" units="mm" scaling="1/10" displayDecimals="1" />
    </fields>
    <message name="Msg1" id="1">
        <ref field="Distance" />
    </message>
</schema>
```
In case the application code works with meters rather millimeters, the relevant code would like like:
```cpp
comms::units::setMeters(msg1.field_distance(), 1.123)
```
or
```cpp
auto distInMeters = comms::units::getMeters<double>(msg1.field_distance());
```
When working with emscripten wrappers there is a need to explicitly provide the wrapping member
functions for the relevant field class(es). The **commsdsl2emscripten** code generator provides
a way to inject the custom code the same way as it does **commmsdsl2comms**.

In the case described above we would like to add member functions allowing to get / set meters
to the fields value. To achieve that we need to create appropriate file injecting "public"
portion of extra code to the field definition:

include/cc_emscripten/my_prot/field/Distance.h.public
```cpp
double getMeters() const
{
    return comms::units::getMeters<double>(*this);
}

void setMeters(double val)
{
    comms::units::setMeters(*this, val);
}
```
The **commsdsl2emscripten** will put the code above in the relevant header.

Note that there might be a need to add extra include statement in `.inc` file:

include/cc_emscripten/my_prot/field/Distance.h.inc
```cpp
#include "comms/units.h"
```

There is also a need to add bindings for the added functions. To do so the relevant `.bind` file can be created for the cpp file:

cc_emscripten/my_prot/field/Distance.cpp.bind
```cpp
.function("getMeters", &field_Distance::getMeters)
.function("setMeters", &field_Distance::setMeters)
```

Then the javascript code can use the added extra functions:
```js
msg = new my_prot.message_Msg1();
msg.field_distance().ref().setMeters(1.234);
```
