# Manual of **commsdsl2tools_qt**

## Overview
The **commsdsl2tools_qt** is a code generation tool provided by this project.
It generates CMake project that can be used to build the **protocol plugin** for the
[CommsChampion Tools](https://github.com/commschamp/cc_tools_qt) using
[CommsDSL](https://commschamp.github.io/commsdsl_spec/) schema file(s).

## Command Line Arguments
The **commsdsl2tools_qt** utility has multiple command line arguments, please
use `-h` option for the full list as well as default option values. 

```
$> /path/to/commsdsl2tools_qt -h
```
Below is a summary of most important ones.

### Selecting Schema Files
Selecting of the schema files is very similar to how it is done for the
[commsdsl2comms](Manual_commsdsl2comms.md#selecting-schema-files).

List all the schema files at the end of the command line arguments:

```
$> /path/to/commsdsl2tools_qt <args> schema1.xml schema2.xml schema3.xml ...
```
The schema files will be processed **in order** of their listing.

When the input files are listed in the single file:
```
$> /path/to/commsdsl2tools_qt -i schemas_list.txt
```

When a schemas listing file contains *relative* paths to the schema files use
`-p` option to specify the absolute path prefix.
```
$> /path/to/commsdsl2tools_qt -i schemas_list.txt -p /path/to/schemas/dir
```

### Output Directory
By default the output CMake project is written to the current directory. It
is possible to change that using `-o` option.
```
$> /path/to/commsdsl2tools_qt -o /some/output/dir schema.xml
```

### Injecting Custom Code
The **commsdsl2tools_qt** utility allows injection of custom code into the
generated project in case the default code is incorrect and/or incomplete. For this
purpose `-c` option with path to directory containing custom code snippets is used.
```
$> /path/to/commsdsl2tools_qt -c /path/to/custom/code/snippets schema.xml
```
Please read [Custom Code](#custom-code) section below for more details on
how to format and where to place the custom code.

### Providing Plugin Information
The protocol definition plugin of the [CommsChampion Tools](https://github.com/commschamp/cc_tools_qt)
is expected to provide some meta information of its name and description.
Also the protocol plugin requires selecting a single `<frame>` name
(in case multiple `<frame>`-s are defined in the schema files) and the
`<interface>` name (in case multiple `<interface>`-s are defined in the schema
files).

To provide the necessary information use `--protocol` command line option:

```
$> /path/to/commsdsl2tools_qt --protocol "frame_id:interface_id:protocol_name:description:plugin_id"
```

In case there is only one `<frame>` and/or only one `<interface>` (implicit or explicit)
the relevant id can be omitted. For example:

```
$> /path/to/commsdsl2tools_qt --protocol "::My Protocol:My Protocol Description:my_protocol_id"
```

Colon (:) separated elements at the end can be omitted. In such case the **commsdsl2tools_qt** code
generator comes up with some default values.

```
$> /path/to/commsdsl2tools_qt --protocol "SomeFrame:SomeInterface:My Protocol"
```

It is possible to add support for multiple protocol plugins (with different frames / interfaces)
in the same project. In such case the command line argument can use comma separation
between the configurations. For example:

```
$> /path/to/commsdsl2tools_qt --protocol \
    "Frame1:Interface1:My Protocol (1):Description (1),Frame2:Interface2:My Protocol (2):Description (2)"
```

### Changing Main Namespace
The code generated by the **commsdsl2tools_qt** depends on the code generated by
the **commsdsl2comms**. If the code generated by the **commsdsl2comms**
[changed its main namespace](Manual_commsdsl2comms.md#changing-main-namespace)
then it is required to change the main namespace for the code generated by
the **commsdsl2tools_qt** as well.
```
$> /path/to/commsdsl2tools_qt -n other_ns_name schema.xml
```

### Using Subsets of Messages
The generated code of the protocol plugin for the [CommsChampion Tools](https://github.com/commschamp/cc_tools_qt)
includes all the messages defined in the schema file(s). Sometimes, when the
protocol contains too many messages it can become a problem for the compiler
(running out of heap space for example). In many cases it can be more practical
to reduce number of messages (many can get deprecated for example) to support in
the plugin. To do so the schema file(s) should be split into multiple files
(for example single message definition per file) and only necessary files
are passed to the code generator (see [Selecting Schema Files](#selecting-schema-files)
section above).

## Custom Code
As was already mentioned earlier, **commsdsl2tools_qt** utility allows injection
of custom code snippets in the generated code.
The [CommsChampion Tools](https://github.com/commschamp/cc_tools_qt) themselves
use C++17 (or later). It is recommended to also use C++17 code snippets for the
[custom code injection](#injecting-custom-code) (using `-c` command line option
specifying directory with custom code snippets).

Most of the files (related to the protocol definition itself) do **not** support
custom code injection. It is the job of the **commsdsl2comms** to provide
the correct protocol definition and the custom code injection can be done there.

The custom code injection is available for classes and files relevant for
plugin control inside the [CommsChampion Tools](https://github.com/commschamp/cc_tools_qt),
which reside in the `cc_tools_qt_plugin/<name>/plugin` folder of the generated
project.

Similar to the [custom code injection defined for the commsdsl2comms](Manual_commsdsl2comms.md##custom-code)
the relevant code snippets are expected to reside in the same relative path as the
generated and to have specific extensions:

- **.inc** - Add extra include statements to the file.
- **.extend** - Extend the defined original class.
- **.replace** - Completely replace the original file.

For example:
- `cc_tools_qt_plugin/demo/plugin/Plugin_demo.h.extend`
- `cc_tools_qt_plugin/demo/plugin/Plugin_demo.cpp.extend`
- `cc_tools_qt_plugin/demo/plugin/Plugin_demo.cpp.inc`
- `cc_tools_qt_plugin/demo/plugin/Plugin_demo.json.replace`

When extending a class, the original class is renamed by adding the `Orig` suffix to
its name and the code from the **.extend** file is just added after the original
code within the same namespace. The extending code is expected to extend the
original class and add the necessary functionality.

For example the contents of the `cc_tools_qt_plugin/demo/plugin/Plugin_demo.h.extend`:
```
// This is extension code
class Plugin_demo : public Plugin_demoOrig
{
    Q_OBJECT
    Q_PLUGIN_METADATA(IID "Demo" FILE "Plugin_demo.json")
    Q_INTERFACES(cc_tools_qt::Plugin)

public:
    Plugin_demo();
    virtual ~Plugin_demo();

private:
    ... // Some extra private members
};
```

The **commsdsl2tools_qt** utility will also copy all the files, residing in the
source directory and not having any of the special suffixes (**.extend**, **.replace**,
**.inc**, etc...) as-is without modification into the output directory
preserving their relative path.

Using such copy of the extra files it is possible to add any extra functionality
to the protocol plugin (such as extra dialogs or forcing messages exchange base on
the reported events).

However, any extra files need to be added to the generated `CMakeLists.txt`. To
do so there is a need to create `CMakeLists.txt.sources` file in the code injection
directory and list all the necessary files there. The contents of the `CMakeLists.txt.sources`
will be added to the `src` variable inside the `cc_plugin` function in the
generated `CMakeLists.txt` file.

For example to add some dialog code, the contents of the `CMakeLists.txt.sources` can be:
```
cc_tools_qt_plugin/test6/plugin/MyDialog.cpp
cc_tools_qt_plugin/test6/plugin/MyDialog.ui
```

Note that the generated `CMakeLists.txt` has the following variables set:
```
set (CMAKE_AUTOMOC ON)
set (CMAKE_AUTOUIC ON)
set (CMAKE_AUTORCC ON)
```
It allows having all the necessary files listed in the sources (including **.ui** and **.qrc** files)
and there is no need to list headers which use `Q_OBJECT` macro (but only if there is
related **.cpp** added to the sources), the moc-ing will
be done automatically.
