//
// Copyright 2025 - 2025 (C). Alex Robenko. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "LatexGenerator.h"

#include "Latex.h"
#include "LatexBitfieldField.h"
#include "LatexBundleField.h"
#include "LatexDataField.h"
#include "LatexCmake.h"
#include "LatexEnumField.h"
#include "LatexFloatField.h"
#include "LatexFrame.h"
#include "LatexIntField.h"
#include "LatexListField.h"
#include "LatexMessage.h"
#include "LatexNamespace.h"
#include "LatexOptionalField.h"
#include "LatexProgramOptions.h"
#include "LatexRefField.h"
#include "LatexSchema.h"
#include "LatexSetField.h"
#include "LatexStringField.h"
#include "LatexVariantField.h"

#include "commsdsl/version.h"
#include "commsdsl/gen/comms.h"
#include "commsdsl/gen/strings.h"
#include "commsdsl/gen/util.h"

#include <cassert>
#include <fstream>
#include <filesystem>

namespace fs = std::filesystem;
namespace comms = commsdsl::gen::comms;
namespace strings = commsdsl::gen::strings;
namespace util = commsdsl::gen::util;

namespace commsdsl2latex
{

namespace 
{

int latexSectionElemIndexInternal(const commsdsl::gen::GenElem& elem)
{
    auto* parent = elem.genGetParent();
    auto type = elem.genElemType();
    if (parent == nullptr) {
        assert(elem.genElemType() == commsdsl::gen::GenElem::Type_Schema);
        auto& schema = LatexSchema::latexCast(commsdsl::gen::GenSchema::genCast(elem));
        if (schema.latexTitle().empty()) {
            return -1;
        }

        return 0U;
    }

    auto parentIndex = latexSectionElemIndexInternal(*parent);
    if (type == commsdsl::gen::GenElem::Type_Namespace) {
        auto& ns = LatexNamespace::latexCast(commsdsl::gen::GenNamespace::genCast(elem));
        if (ns.latexTitle().empty()) {
            return parentIndex;
        }

        return parentIndex + 1;
    }

    return parentIndex + 1;
}

static const std::string& latexLabelPrefix(commsdsl::gen::GenElem::Type type)
{
    static const std::string Map[] = {
        /* Type_Invalid */ std::string(),
        /* Type_Namespace */ "ns_",
        /* Type_Message */ "msg_",
        /* Type_Field */ "field_",
        /* Type_Interface */ "iface_",
        /* Type_Frame */ "frame_",
        /* Type_Layer */ "layer_",
        /* Type_Schema */ "schema_",        
    };
    static const std::size_t MapSize = std::extent<decltype(Map)>::value;
    static_assert(MapSize == commsdsl::gen::GenElem::Type_NumOfValues);

    auto idx = static_cast<unsigned>(type);
    assert (idx < MapSize);
    if (MapSize <= idx) {
        idx = static_cast<decltype(idx)>(commsdsl::gen::GenElem::Type_Invalid);
    }

    return Map[idx];
}

} // namespace 
    

const std::string& LatexGenerator::latexFileGeneratedComment()
{
    static const std::string Str =
        "% Generated by commsdsl2latex v" + std::to_string(commsdsl::versionMajor()) +
        '.' + std::to_string(commsdsl::versionMinor()) + '.' +
        std::to_string(commsdsl::versionPatch()) + '\n';
    return Str;
}

const std::string& LatexGenerator::latexCodeInjectCommentPrefix()
{
    static const std::string Str = "% [CODE INJECT]: ";
    return Str;
}

std::string LatexGenerator::latexWrapInput(const std::string& filePath)
{
    return "\\input{" + filePath + "}";
}

void LatexGenerator::latexWrapInputInPlace(std::string& filePath)
{
    filePath = latexWrapInput(filePath);
}

const std::string& LatexGenerator::latexSectionDirective(const GenElem& elem)
{
    static const std::string Map[] = {
        /* 0 */ "\\section",
        /* 1 */ "\\subsection",
        /* 2 */ "\\subsubsection",
        /* 3 */ "\\paragraph",
        /* 4 */ "\\subparagraph",
    };
    static const std::size_t MapSize = std::extent<decltype(Map)>::value;

    int idx = latexSectionElemIndexInternal(elem);
    assert(int(0) <= idx);
    if (idx < 0) {
        return Map[0];
    }

    if (MapSize <= static_cast<unsigned>(idx)) {
        static const std::string Bold("\\subsubparagraph");
        return Bold;
    }

    return Map[idx];
}

std::string LatexGenerator::latexLabelId(const GenElem& elem)
{
    std::string prefix;
    auto* parent = elem.genGetParent();
    if (parent != nullptr) {
        prefix = latexLabelId(*parent);
    }

    auto elemName = elem.genName();
    if (!elemName.empty()) {
        elemName = latexLabelPrefix(elem.genElemType()) + elemName;
    }

    if ((!prefix.empty()) && (!elemName.empty())) {
        prefix += ':';
    }

    return prefix + elemName;
}

std::string LatexGenerator::latexEscDisplayName(const std::string& displayName, const std::string& name)
{
    auto result = util::genDisplayName(displayName, name);
    if (result.empty()) {
        result = name;
    }

    return util::genStrReplace(result, "_", "\\_");
}

void LatexGenerator::latexEnsureNewLineBreak(std::string& str)
{
    if (str.empty()) {
        return;
    }

    if (str.back() != '\n') {
        str.push_back('\n');
    }

    str.append("\\\\\n");
}

std::string LatexGenerator::latexRelPathFor(const GenElem& elem) const
{
    auto scope = comms::genScopeFor(elem, *this);
    return util::genScopeToRelPath(scope);
}

std::string LatexGenerator::latexInputCodePathForFile(const std::string& name) const
{
    return genGetCodeDir() + '/' + name;
}

bool LatexGenerator::genWriteImpl()
{
    assert(&genCurrentSchema() == &genProtocolSchema());
    return 
        Latex::latexWrite(*this) &&
        LatexCmake::latexWrite(*this) &&
        latexWriteExtraFilesInternal();
}

LatexGenerator::GenSchemaPtr LatexGenerator::genCreateSchemaImpl(ParseSchema parseObj, GenElem* parent)
{
    return std::make_unique<LatexSchema>(*this, parseObj, parent);
}

LatexGenerator::GenNamespacePtr LatexGenerator::genCreateNamespaceImpl(ParseNamespace parseObj, GenElem* parent)
{
    return std::make_unique<LatexNamespace>(*this, parseObj, parent);
}

LatexGenerator::GenMessagePtr LatexGenerator::genCreateMessageImpl(ParseMessage parseObj, GenElem* parent)
{
    return std::make_unique<LatexMessage>(*this, parseObj, parent);
}

LatexGenerator::GenFramePtr LatexGenerator::genCreateFrameImpl(ParseFrame parseObj, GenElem* parent)
{
    return std::make_unique<LatexFrame>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateIntFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexIntField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateEnumFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexEnumField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateSetFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexSetField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateFloatFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexFloatField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateBitfieldFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexBitfieldField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateBundleFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexBundleField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateStringFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexStringField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateDataFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexDataField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateListFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexListField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateRefFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexRefField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateOptionalFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexOptionalField>(*this, parseObj, parent);
}

LatexGenerator::GenFieldPtr LatexGenerator::genCreateVariantFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<LatexVariantField>(*this, parseObj, parent);
}

LatexGenerator::OptsProcessResult LatexGenerator::genProcessOptionsImpl(const GenProgramOptions& options)
{
    auto& opts = LatexProgramOptions::latexCast(options);
    m_hasCodeInjectionComments = opts.latexCodeInjectCommentsRequested();

    return OptsProcessResult_Continue;
}

bool LatexGenerator::latexWriteExtraFilesInternal() const
{
    const std::vector<std::string> ReservedExt = {
        strings::genReplaceFileSuffixStr(),
        strings::genAppendFileSuffixStr(),
        strings::genPackageFileSuffixStr(),
        strings::genPackageAppendFileSuffixStr(),
        strings::genContentFileSuffixStr(),
        strings::genContentPrependFileSuffixStr(),
        strings::genContentAppendFileSuffixStr(),
        strings::genTitleFileSuffixStr(),
        strings::genTitleAppendFileSuffixStr(),
        strings::genMacroFileSuffixStr(),
        strings::genMacroAppendFileSuffixStr(),
        strings::genPdfFileSuffixStr(),
        strings::genHtmlFileSuffixStr(),
        strings::genHtmlAppendFileSuffixStr(),
        strings::genHtmlCmdAppendFileSuffixStr(),
    }; 

    return genCopyExtraSourceFiles(ReservedExt);
}

} // namespace commsdsl2latex
