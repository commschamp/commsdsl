//
// Copyright 2025 - 2025 (C). Alex Robenko. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "LatexGenerator.h"

#include "Latex.h"
#include "LatexCmake.h"
#include "LatexNamespace.h"
#include "LatexProgramOptions.h"
#include "LatexSchema.h"

#include "commsdsl/version.h"
#include "commsdsl/gen/comms.h"
#include "commsdsl/gen/strings.h"
#include "commsdsl/gen/util.h"

#include <cassert>
#include <fstream>
#include <filesystem>

namespace fs = std::filesystem;
namespace comms = commsdsl::gen::comms;
namespace strings = commsdsl::gen::strings;
namespace util = commsdsl::gen::util;

namespace commsdsl2latex
{

namespace 
{

int latexSectionElemIndexInternal(const commsdsl::gen::GenElem& elem)
{
    auto* parent = elem.genGetParent();
    auto type = elem.genElemType();
    if (parent == nullptr) {
        assert(elem.genElemType() == commsdsl::gen::GenElem::Type_Schema);
        auto& schema = LatexSchema::latexCast(commsdsl::gen::GenSchema::genCast(elem));
        if (schema.latexTitle().empty()) {
            return -1;
        }

        return 0U;
    }

    auto parentIndex = latexSectionElemIndexInternal(*parent);
    if (type == commsdsl::gen::GenElem::Type_Namespace) {
        auto& ns = LatexNamespace::latexCast(commsdsl::gen::GenNamespace::genCast(elem));
        if (ns.latexTitle().empty()) {
            return parentIndex;
        }

        return parentIndex + 1;
    }

    return parentIndex + 1;
}

} // namespace 
    

const std::string& LatexGenerator::latexFileGeneratedComment()
{
    static const std::string Str =
        "% Generated by commsdsl2latex v" + std::to_string(commsdsl::versionMajor()) +
        '.' + std::to_string(commsdsl::versionMinor()) + '.' +
        std::to_string(commsdsl::versionPatch()) + '\n';
    return Str;
}

const std::string& LatexGenerator::latexCodeInjectCommentPrefix()
{
    static const std::string Str = "% [CODE INJECT]: ";
    return Str;
}

std::string LatexGenerator::latexWrapInput(const std::string& filePath)
{
    return "\\input{" + filePath + "}";
}

void LatexGenerator::latexWrapInputInPlace(std::string& filePath)
{
    filePath = latexWrapInput(filePath);
}

const std::string& LatexGenerator::latexSectionDirective(const GenElem& elem)
{
    static const std::string Map[] = {
        /* 0 */ "\\section",
        /* 1 */ "\\subsection",
        /* 2 */ "\\subsubsection",
        /* 3 */ "\\paragraph",
        /* 4 */ "\\subparagraph",
    };
    static const std::size_t MapSize = std::extent<decltype(Map)>::value;

    int idx = latexSectionElemIndexInternal(elem);
    assert(int(0) <= idx);
    if (idx < 0) {
        return Map[0];
    }

    if (MapSize <= static_cast<unsigned>(idx)) {
        static const std::string Bold("\\textbf");
        return Bold;
    }

    return Map[idx];
}

std::string LatexGenerator::latexLabelId(const GenElem& elem)
{
    std::string parentPrefix;
    auto* parent = elem.genGetParent();
    if (parent != nullptr) {
        parentPrefix = latexLabelId(*parent);
    }

    if (!parentPrefix.empty()) {
        parentPrefix += ':';
    }

    return parentPrefix + elem.genName();
}

std::string LatexGenerator::latexRelPathFor(const GenElem& elem)
{
    auto scope = comms::genScopeFor(elem, *this);
    return util::genStrReplace(scope, "::", "/");
}

std::string LatexGenerator::latexInputCodePathForFile(const std::string& name) const
{
    return genGetCodeDir() + '/' + name;
}

bool LatexGenerator::genWriteImpl()
{
    assert(&genCurrentSchema() == &genProtocolSchema());
    return 
        Latex::latexWrite(*this) &&
        LatexCmake::latexWrite(*this) &&
        latexWriteExtraFilesInternal();
}

LatexGenerator::GenSchemaPtr LatexGenerator::genCreateSchemaImpl(ParseSchema parseObj, GenElem* parent)
{
    return std::make_unique<LatexSchema>(*this, parseObj, parent);
}

LatexGenerator::GenNamespacePtr LatexGenerator::genCreateNamespaceImpl(ParseNamespace parseObj, GenElem* parent)
{
    return std::make_unique<LatexNamespace>(*this, parseObj, parent);
}

LatexGenerator::OptsProcessResult LatexGenerator::genProcessOptionsImpl(const GenProgramOptions& options)
{
    auto& opts = LatexProgramOptions::latexCast(options);
    m_hasCodeInjectionComments = opts.latexCodeInjectCommentsRequested();

    return OptsProcessResult_Continue;
}

bool LatexGenerator::latexWriteExtraFilesInternal() const
{
    const std::vector<std::string> ReservedExt = {
        //strings::genSourcesFileSuffixStr(),
    }; 

    return genCopyExtraSourceFiles(ReservedExt);
}

} // namespace commsdsl2latex
