//
// Copyright 2025 - 2025 (C). Alex Robenko. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "CGenerator.h"

// #include "C.h"
// #include "CBitfieldField.h"
// #include "CBundleField.h"
// #include "CDataField.h"
// #include "CCmake.h"
// #include "CEnumField.h"
// #include "CFloatField.h"
// #include "CFrame.h"
#include "CIntField.h"
// #include "CListField.h"
// #include "CMessage.h"
// #include "CNamespace.h"
// #include "COptionalField.h"
#include "CProgramOptions.h"
// #include "CRefField.h"
// #include "CSchema.h"
// #include "CSetField.h"
// #include "CStringField.h"
// #include "CVariantField.h"

#include "commsdsl/version.h"
#include "commsdsl/gen/comms.h"
#include "commsdsl/gen/strings.h"
#include "commsdsl/gen/util.h"

#include <cassert>
#include <fstream>
#include <filesystem>
#include <iomanip>
#include <sstream>

namespace fs = std::filesystem;
namespace comms = commsdsl::gen::comms;
namespace strings = commsdsl::gen::strings;
namespace util = commsdsl::gen::util;

namespace commsdsl2c
{

const std::string& CGenerator::cFileGeneratedComment()
{
    static const std::string Str =
        "// Generated by commsdsl2c v" + std::to_string(commsdsl::versionMajor()) +
        '.' + std::to_string(commsdsl::versionMinor()) + '.' +
        std::to_string(commsdsl::versionPatch()) + '\n';
    return Str;
}

std::string CGenerator::cRelHeaderFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetTopNamespace() + '/' + comms::genRelHeaderPathFor(elem, *this);
}

std::string CGenerator::cAbsHeaderFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetOutputDir() + '/' + strings::genIncludeDirStr() + '/' + cRelHeaderFor(elem);
}

std::string CGenerator::cRelSourceFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetTopNamespace() + '/' + comms::genRelSourcePathFor(elem, *this);
}

std::string CGenerator::cAbsSourceFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetOutputDir() + '/' + cRelSourceFor(elem);
}

std::string CGenerator::cInputAbsHeaderFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetCodeDir() + '/' + strings::genIncludeDirStr() + '/' + cRelHeaderFor(elem);
}

std::string CGenerator::cInputAbsSourceFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetCodeDir() + '/' + cRelSourceFor(elem);
}

std::string CGenerator::cScopeToName(const std::string& scope)
{
    return util::genStrReplace(scope, "::", "_");
}

bool CGenerator::genWriteImpl()
{
    assert(&genCurrentSchema() == &genProtocolSchema());
    return 
        cWriteExtraFilesInternal();
}

// CGenerator::GenSchemaPtr CGenerator::genCreateSchemaImpl(ParseSchema parseObj, GenElem* parent)
// {
//     return std::make_unique<CSchema>(*this, parseObj, parent);
// }

// CGenerator::GenNamespacePtr CGenerator::genCreateNamespaceImpl(ParseNamespace parseObj, GenElem* parent)
// {
//     return std::make_unique<CNamespace>(*this, parseObj, parent);
// }

// CGenerator::GenMessagePtr CGenerator::genCreateMessageImpl(ParseMessage parseObj, GenElem* parent)
// {
//     return std::make_unique<CMessage>(*this, parseObj, parent);
// }

// CGenerator::GenFramePtr CGenerator::genCreateFrameImpl(ParseFrame parseObj, GenElem* parent)
// {
//     return std::make_unique<CFrame>(*this, parseObj, parent);
// }

CGenerator::GenFieldPtr CGenerator::genCreateIntFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CIntField>(*this, parseObj, parent);
}

// CGenerator::GenFieldPtr CGenerator::genCreateEnumFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CEnumField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateSetFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CSetField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateFloatFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CFloatField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateBitfieldFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CBitfieldField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateBundleFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CBundleField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateStringFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CStringField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateDataFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CDataField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateListFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CListField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateRefFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CRefField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateOptionalFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<COptionalField>(*this, parseObj, parent);
// }

// CGenerator::GenFieldPtr CGenerator::genCreateVariantFieldImpl(ParseField parseObj, GenElem* parent)
// {
//     return std::make_unique<CVariantField>(*this, parseObj, parent);
// }

CGenerator::OptsProcessResult CGenerator::genProcessOptionsImpl(const GenProgramOptions& options)
{
    [[maybe_unused]] auto& opts = CProgramOptions::cCast(options);

    genSetTopNamespace("cc_c");
    return OptsProcessResult_Continue;
}

bool CGenerator::cWriteExtraFilesInternal() const
{
    const std::vector<std::string> ReservedExt = {
    }; 

    return genCopyExtraSourceFiles(ReservedExt);
}

} // namespace commsdsl2c
