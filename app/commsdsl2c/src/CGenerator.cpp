//
// Copyright 2025 - 2025 (C). Alex Robenko. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "CGenerator.h"

#include "CBitfieldField.h"
#include "CBundleField.h"
#include "CDataField.h"
#include "CCmake.h"
#include "CEnumField.h"
#include "CFloatField.h"
// #include "CFrame.h"
#include "CInterface.h"
#include "CIntField.h"
#include "CListField.h"
#include "CMessage.h"
#include "CNamespace.h"
#include "COptionalField.h"
#include "CProgramOptions.h"
#include "CProtocolOptions.h"
#include "CRefField.h"
#include "CSchema.h"
#include "CSetField.h"
#include "CStringField.h"
#include "CVariantField.h"

#include "commsdsl/version.h"
#include "commsdsl/gen/comms.h"
#include "commsdsl/gen/strings.h"
#include "commsdsl/gen/util.h"

#include <algorithm>
#include <cassert>
#include <fstream>
#include <filesystem>
#include <iomanip>
#include <sstream>

namespace fs = std::filesystem;
namespace comms = commsdsl::gen::comms;
namespace strings = commsdsl::gen::strings;
namespace util = commsdsl::gen::util;

namespace commsdsl2c
{

const std::string& CGenerator::cFileGeneratedComment()
{
    static const std::string Str =
        "// Generated by commsdsl2c v" + std::to_string(commsdsl::versionMajor()) +
        '.' + std::to_string(commsdsl::versionMinor()) + '.' +
        std::to_string(commsdsl::versionPatch()) + '\n';
    return Str;
}

std::string CGenerator::cRelHeaderFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetTopNamespace() + '/' + comms::genRelHeaderPathFor(elem, *this);
}

std::string CGenerator::cAbsHeaderFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetOutputDir() + '/' + strings::genIncludeDirStr() + '/' + cRelHeaderFor(elem);
}

std::string CGenerator::cRelSourceFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetTopNamespace() + '/' + comms::genRelSourcePathFor(elem, *this);
}

std::string CGenerator::cAbsSourceFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetOutputDir() + '/' + cRelSourceFor(elem);
}

std::string CGenerator::cRelCommsHeaderFor(const commsdsl::gen::GenElem& elem) const
{
    auto scope = comms::genScopeFor(elem, *this) + strings::genCommsNameSuffixStr();
    return genGetTopNamespace() + '/' + util::genScopeToRelPath(scope) + strings::genCppHeaderSuffixStr();
}

std::string CGenerator::cAbsCommsHeaderFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetOutputDir() + '/' + cRelCommsHeaderFor(elem);
}

std::string CGenerator::cRelHeaderForNamespaceMember(const std::string& name, const CNamespace& parent)
{
    return genGetTopNamespace() + '/' + comms::genRelHeaderForNamespaceMember(name, *this, parent);
}

std::string CGenerator::cAbsHeaderForNamespaceMember(const std::string& name, const CNamespace& parent)
{
    return genGetOutputDir() + '/' + strings::genIncludeDirStr() + '/' + cRelHeaderForNamespaceMember(name, parent);
}

std::string CGenerator::cInputAbsHeaderFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetCodeDir() + '/' + strings::genIncludeDirStr() + '/' + cRelHeaderFor(elem);
}

std::string CGenerator::cInputAbsSourceFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetCodeDir() + '/' + cRelSourceFor(elem);
}

std::string CGenerator::cNameFor(const commsdsl::gen::GenElem& elem) const
{
    return cNamesPrefix() + cScopeToName(comms::genScopeFor(elem, *this, false));
}

std::string CGenerator::cScopeToName(const std::string& scope)
{
    return util::genStrReplace(scope, "::", "_");
}

const std::string& CGenerator::cCppGuardBegin()
{
    static const std::string Str = 
        "#ifdef __cplusplus\n"
        "extern \"C\" {\n"
        "#else\n"
        "#include <stdbool.h>\n"
        "#endif\n"
        ;

    return Str;
}

const std::string& CGenerator::cCppGuardEnd()
{
    static const std::string Str = 
        "#ifdef __cplusplus\n"
        "}\n"
        "#endif\n"
        ;

    return Str;
}

const std::string& CGenerator::cNamesPrefix() const
{
    return m_namesPrefix;
}

const CGenerator::GenStringsList& CGenerator::cProtocolOptions() const
{
    return m_commsOptions;
}

const CInterface* CGenerator::cForcedInterface() const
{
    return m_forcedInterface;
}

bool CGenerator::genPrepareImpl()
{
    return 
        cPrepareNamesPrefixInternal() &&
        cPrepareCommsOptionsInternal();
}

bool CGenerator::genWriteImpl()
{
    assert(&genCurrentSchema() == &genProtocolSchema());
    return 
        CProtocolOptions::cWrite(*this) &&
        CCmake::cWrite(*this) &&
        cWriteExtraFilesInternal();
}

CGenerator::GenSchemaPtr CGenerator::genCreateSchemaImpl(ParseSchema parseObj, GenElem* parent)
{
    return std::make_unique<CSchema>(*this, parseObj, parent);
}

CGenerator::GenNamespacePtr CGenerator::genCreateNamespaceImpl(ParseNamespace parseObj, GenElem* parent)
{
    return std::make_unique<CNamespace>(*this, parseObj, parent);
}

CGenerator::GenInterfacePtr CGenerator::genCreateInterfaceImpl(ParseInterface parseObj, GenElem* parent)
{
    return std::make_unique<CInterface>(*this, parseObj, parent);
}

CGenerator::GenMessagePtr CGenerator::genCreateMessageImpl(ParseMessage parseObj, GenElem* parent)
{
    return std::make_unique<CMessage>(*this, parseObj, parent);
}

// CGenerator::GenFramePtr CGenerator::genCreateFrameImpl(ParseFrame parseObj, GenElem* parent)
// {
//     return std::make_unique<CFrame>(*this, parseObj, parent);
// }

CGenerator::GenFieldPtr CGenerator::genCreateIntFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CIntField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateEnumFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CEnumField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateSetFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CSetField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateFloatFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CFloatField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateBitfieldFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CBitfieldField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateBundleFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CBundleField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateStringFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CStringField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateDataFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CDataField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateListFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CListField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateRefFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CRefField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateOptionalFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<COptionalField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateVariantFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CVariantField>(*this, parseObj, parent);
}

CGenerator::OptsProcessResult CGenerator::genProcessOptionsImpl(const GenProgramOptions& options)
{
    auto& opts = CProgramOptions::cCast(options);

    cSetNamesPrefixInternal(opts.cGetNamesPrefix());
    cSetCommsOptionsInternal(opts.cGetCommsOptions());
    cSetCommsinterfaceInternal(opts.cGetCommsInterface());
    genSetTopNamespace("cc_c");
    return OptsProcessResult_Continue;
}

bool CGenerator::cWriteExtraFilesInternal() const
{
    const std::vector<std::string> ReservedExt = {
    }; 

    return genCopyExtraSourceFiles(ReservedExt);
}

void CGenerator::cSetNamesPrefixInternal(const std::string& value)
{
    m_namesPrefix = util::genStrToName(value);
}

void CGenerator::cSetCommsOptionsInternal(const std::string& value)
{
    m_commsOptions = util::genStrSplit(value, "::");
}

void CGenerator::cSetCommsinterfaceInternal(const std::string& value)
{
    m_forcedInterfaceName = value;
}

bool CGenerator::cPrepareNamesPrefixInternal()
{
    if (m_namesPrefix.empty()) {
        m_namesPrefix = genProtocolSchema().genMainNamespace();
    }
    m_namesPrefix += '_';
    return true;
}

bool CGenerator::cPrepareCommsOptionsInternal()
{
    auto& schemas = genSchemas();
    while (m_commsOptions.size() < schemas.size()) {
        if (!schemas[m_commsOptions.size()]->genHasAnyReferencedComponent()) {
            m_commsOptions.push_back(strings::genEmptyString());
            continue;
        }

        m_commsOptions.push_back(strings::genDefaultOptionsClassStr());
    }

    for (auto idx = 0U; idx < m_commsOptions.size(); ++idx) {
        auto& optStr = m_commsOptions[idx];
        if (optStr.empty()) {
            continue;
        }

        auto scopePos = optStr.find("::");
        if (scopePos != std::string::npos) {
            continue;
        }

        if (schemas.size() <= idx) {
            genLogger().genError("Unable to determine options scope from \"" + optStr + "\" options string.");
            return false;
        }

        optStr = schemas[idx]->genMainNamespace() + "::" + comms::genScopeForOptions(optStr, *this, false, true);
    }

    // Clean empty strings
    m_commsOptions.erase(
        std::remove_if(
            m_commsOptions.begin(), m_commsOptions.end(),
            [](auto& str)
            {
                return str.empty();
            }),
        m_commsOptions.end());    

    return true;
}

bool CGenerator::cPrepareForcedInterfaceInternal()
{
    if (m_forcedInterfaceName.empty()) {
        return true;
    }

    auto* iFace = genFindInterface(m_forcedInterfaceName);
    if (iFace == nullptr) {
        genLogger().genError("Unknown forced interface \"" + m_forcedInterfaceName + "\"");
        return false;
    }

    m_forcedInterface = CInterface::cCast(iFace);
    return true;
}

} // namespace commsdsl2c
