//
// Copyright 2025 - 2025 (C). Alex Robenko. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "CGenerator.h"

#include "CBitfieldField.h"
#include "CChecksumLayer.h"
#include "CBundleField.h"
#include "CCustomLayer.h"
#include "CDataField.h"
#include "CDoxygen.h"
#include "CCmake.h"
#include "CEnumField.h"
#include "CErrorStatus.h"
#include "CFloatField.h"
#include "CFrame.h"
#include "CIdLayer.h"
#include "CInterface.h"
#include "CIntField.h"
#include "CListField.h"
#include "CMessage.h"
#include "CNamespace.h"
#include "COptionalField.h"
#include "CPayloadLayer.h"
#include "CProgramOptions.h"
#include "CProtocolOptions.h"
#include "CRefField.h"
#include "CSchema.h"
#include "CSetField.h"
#include "CSizeLayer.h"
#include "CStringField.h"
#include "CSyncLayer.h"
#include "CValueLayer.h"
#include "CVariantField.h"
#include "CVersion.h"

#include "commsdsl/version.h"
#include "commsdsl/gen/comms.h"
#include "commsdsl/gen/strings.h"
#include "commsdsl/gen/util.h"

#include <algorithm>
#include <cassert>
#include <fstream>
#include <filesystem>
#include <iomanip>
#include <sstream>

namespace fs = std::filesystem;
namespace comms = commsdsl::gen::comms;
namespace strings = commsdsl::gen::strings;
namespace util = commsdsl::gen::util;

namespace commsdsl2c
{

const std::string& CGenerator::cFileGeneratedComment()
{
    static const std::string Str =
        "// Generated by commsdsl2c v" + std::to_string(commsdsl::versionMajor()) +
        '.' + std::to_string(commsdsl::versionMinor()) + '.' +
        std::to_string(commsdsl::versionPatch()) + '\n';
    return Str;
}

std::string CGenerator::cRelHeaderFor(const GenElem& elem) const
{
    auto& schema = genSchemaOf(elem);
    if (&schema != &genProtocolSchema()) {
        return genGetTopNamespace() + '/' + comms::genRelHeaderPathFor(elem, *this);
    }

    return genGetTopNamespace() + '/' + m_namesPrefix + '/' + comms::genRelHeaderPathFor(elem, *this, false);
}

std::string CGenerator::cAbsHeaderFor(const GenElem& elem) const
{
    return genGetOutputDir() + '/' + strings::genIncludeDirStr() + '/' + cRelHeaderFor(elem);
}

std::string CGenerator::cRelSourceFor(const GenElem& elem) const
{
    auto& schema = genSchemaOf(elem);
    if (&schema != &genProtocolSchema()) {
        return genGetTopNamespace() + '/' + comms::genRelSourcePathFor(elem, *this);
    }

    return genGetTopNamespace() + '/' + m_namesPrefix + '/' + comms::genRelSourcePathFor(elem, *this, false);
}

std::string CGenerator::cAbsSourceFor(const GenElem& elem) const
{
    return genGetOutputDir() + '/' + cRelSourceFor(elem);
}

std::string CGenerator::cRelCommsHeaderFor(const GenElem& elem) const
{
    auto& schema = genSchemaOf(elem);
    if (&schema != &genProtocolSchema()) {
        auto scope = comms::genScopeFor(elem, *this) + strings::genCommsNameSuffixStr();
        return genGetTopNamespace() + '/' + util::genScopeToRelPath(scope) + strings::genCppHeaderSuffixStr();
    }

    auto scope = m_namesPrefix + "::" + comms::genScopeFor(elem, *this, false) + strings::genCommsNameSuffixStr();
    return genGetTopNamespace() + '/' + util::genScopeToRelPath(scope) + strings::genCppHeaderSuffixStr();
}

std::string CGenerator::cAbsCommsHeaderFor(const GenElem& elem) const
{
    return genGetOutputDir() + '/' + cRelCommsHeaderFor(elem);
}

std::string CGenerator::cRelHeaderForNamespaceMember(const std::string& name, const CNamespace& parent) const
{
    auto& schema = genSchemaOf(parent);
    if (&schema != &genProtocolSchema()) {
        return genGetTopNamespace() + '/' + comms::genRelHeaderForNamespaceMember(name, *this, parent);
    }

    return genGetTopNamespace() + '/' + m_namesPrefix + '/' + comms::genRelHeaderForNamespaceMember(name, *this, parent, false);
}

std::string CGenerator::cAbsHeaderForNamespaceMember(const std::string& name, const CNamespace& parent) const
{
    return genGetOutputDir() + '/' + strings::genIncludeDirStr() + '/' + cRelHeaderForNamespaceMember(name, parent);
}

std::string CGenerator::cRelCommsHeaderForNamespaceMember(const std::string& name, const CNamespace& parent) const
{
    auto& schema = genSchemaOf(parent);
    if (&schema != &genProtocolSchema()) {
        return genGetTopNamespace() + '/' + comms::genRelHeaderForNamespaceMember(name, *this, parent);
    }

    return genGetTopNamespace() + '/' + m_namesPrefix + '/' + comms::genRelHeaderForNamespaceMember(name + strings::genCommsNameSuffixStr(), *this, parent, false);
}

std::string CGenerator::cAbsCommsHeaderForNamespaceMember(const std::string& name, const CNamespace& parent) const
{
    return genGetOutputDir() + '/' + cRelCommsHeaderForNamespaceMember(name, parent);
}

std::string CGenerator::cRelSourceForNamespaceMember(const std::string& name, const CNamespace& parent) const
{
    auto& schema = genSchemaOf(parent);
    if (&schema != &genProtocolSchema()) {
        return genGetTopNamespace() + '/' + comms::genRelSourceForNamespaceMember(name, *this, parent);
    }

    return genGetTopNamespace() + '/' + m_namesPrefix + '/' + comms::genRelSourceForNamespaceMember(name, *this, parent, false);
}

std::string CGenerator::cAbsSourceForNamespaceMember(const std::string& name, const CNamespace& parent) const
{
    return genGetOutputDir() + '/' + cRelSourceForNamespaceMember(name, parent);
}

std::string CGenerator::cRelHeaderForInput(const std::string& name, const CNamespace& parent) const
{
    auto& schema = genSchemaOf(parent);
    if (&schema != &genProtocolSchema()) {
        return genGetTopNamespace() + '/' + comms::genRelSourceForNamespaceMember(name, *this, parent);
    }

    return genGetTopNamespace() + '/' + m_namesPrefix + '/' + comms::genRelHeaderForInput(name, *this, parent, false);
}

std::string CGenerator::cAbsHeaderForInput(const std::string& name, const CNamespace& parent) const
{
    return genGetOutputDir() + '/' + cRelHeaderForInput(name, parent);
}

std::string CGenerator::cRelRootHeaderFor(const std::string& name) const
{
    return
        genGetTopNamespace() + '/' +
        m_namesPrefix + '/' +
        name + strings::genCppHeaderSuffixStr();
}

std::string CGenerator::cAbsRootHeaderFor(const std::string& name) const
{
    return genGetOutputDir() + '/' + strings::genIncludeDirStr() + '/' + cRelRootHeaderFor(name);
}

std::string CGenerator::cRelRootSourceFor(const std::string& name) const
{
    return
        genGetTopNamespace() + '/' +
        m_namesPrefix + '/' +
        name + strings::genCppSourceSuffixStr();
}

std::string CGenerator::cAbsRootSourceFor(const std::string& name) const
{
    return genGetOutputDir() + '/' + cRelRootSourceFor(name);
}

std::string CGenerator::cRelPathForDoc(const std::string& name) const
{
    return strings::genDocDirStr() + '/' + name;
}

std::string CGenerator::cAbsPathForDoc(const std::string& name) const
{
    return genGetOutputDir() + '/' + cRelPathForDoc(name);
}

std::string CGenerator::cInputAbsHeaderFor(const GenElem& elem) const
{
    return genGetCodeDir() + '/' + strings::genIncludeDirStr() + '/' + cRelHeaderFor(elem);
}

std::string CGenerator::cInputAbsSourceFor(const GenElem& elem) const
{
    return genGetCodeDir() + '/' + cRelSourceFor(elem);
}

std::string CGenerator::cInputAbsPathForDoc(const std::string& name) const
{
    return genGetCodeDir() + '/' + cRelPathForDoc(name);
}

std::string CGenerator::cInputAbsRootHeaderFor(const std::string& name) const
{
    return genGetCodeDir() + '/' + cRelRootHeaderFor(name);
}

std::string CGenerator::cNameFor(const GenElem& elem) const
{
    auto& schema = genSchemaOf(elem);
    if (&schema != &genProtocolSchema()) {
        return cScopeToName(comms::genScopeFor(elem, *this));
    }

    return cScopeToName(m_namesPrefix + "::" + comms::genScopeFor(elem, *this, false));
}

const std::string& CGenerator::cNamesPrefix() const
{
    return m_namesPrefix;
}

std::string CGenerator::cScopeToName(const std::string& scope)
{
    return util::genStrReplace(scope, "::", "_");
}

const std::string& CGenerator::cCppGuardBegin(bool addBool)
{
    if (addBool) {
        static const std::string Str =
            "#ifdef __cplusplus\n"
            "extern \"C\" {\n"
            "#else\n"
            "#include <stdbool.h>\n"
            "#endif\n"
            ;

        return Str;
    }

    static const std::string Str =
        "#ifdef __cplusplus\n"
        "extern \"C\" {\n"
        "#endif\n"
        ;

    return Str;
}

const std::string& CGenerator::cCppGuardEnd()
{
    static const std::string Str =
        "#ifdef __cplusplus\n"
        "}\n"
        "#endif\n"
        ;

    return Str;
}

const CGenerator::GenStringsList& CGenerator::cProtocolOptions() const
{
    return m_commsOptions;
}

const std::string& CGenerator::cInputName() const
{
    return m_inputName;
}

const CInterface* CGenerator::cForcedInterface() const
{
    return m_forcedInterface;
}

bool CGenerator::genPrepareImpl()
{
    return
        cPrepareNamesPrefixInternal() &&
        cPrepareCommsOptionsInternal() &&
        cPrepareForcedInterfaceInternal() &&
        cPrepareInputNameInternal();
}

bool CGenerator::genWriteImpl()
{
    assert(&genCurrentSchema() == &genProtocolSchema());
    return
        CProtocolOptions::cWrite(*this) &&
        CErrorStatus::cWrite(*this) &&
        CCmake::cWrite(*this) &&
        CDoxygen::cWrite(*this) &&
        CVersion::cWrite(*this) &&
        cWriteExtraFilesInternal();
}

CGenerator::GenSchemaPtr CGenerator::genCreateSchemaImpl(ParseSchema parseObj, GenElem* parent)
{
    return std::make_unique<CSchema>(*this, parseObj, parent);
}

CGenerator::GenNamespacePtr CGenerator::genCreateNamespaceImpl(ParseNamespace parseObj, GenElem* parent)
{
    return std::make_unique<CNamespace>(*this, parseObj, parent);
}

CGenerator::GenInterfacePtr CGenerator::genCreateInterfaceImpl(ParseInterface parseObj, GenElem* parent)
{
    return std::make_unique<CInterface>(*this, parseObj, parent);
}

CGenerator::GenMessagePtr CGenerator::genCreateMessageImpl(ParseMessage parseObj, GenElem* parent)
{
    return std::make_unique<CMessage>(*this, parseObj, parent);
}

CGenerator::GenFramePtr CGenerator::genCreateFrameImpl(ParseFrame parseObj, GenElem* parent)
{
    return std::make_unique<CFrame>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateIntFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CIntField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateEnumFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CEnumField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateSetFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CSetField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateFloatFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CFloatField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateBitfieldFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CBitfieldField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateBundleFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CBundleField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateStringFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CStringField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateDataFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CDataField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateListFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CListField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateRefFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CRefField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateOptionalFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<COptionalField>(*this, parseObj, parent);
}

CGenerator::GenFieldPtr CGenerator::genCreateVariantFieldImpl(ParseField parseObj, GenElem* parent)
{
    return std::make_unique<CVariantField>(*this, parseObj, parent);
}

CGenerator::GenLayerPtr CGenerator::genCreateCustomLayerImpl(ParseLayer parseObj, GenElem* parent)
{
    return std::make_unique<CCustomLayer>(*this, parseObj, parent);
}

CGenerator::GenLayerPtr CGenerator::genCreateSyncLayerImpl(ParseLayer parseObj, GenElem* parent)
{
    return std::make_unique<CSyncLayer>(*this, parseObj, parent);
}

CGenerator::GenLayerPtr CGenerator::genCreateSizeLayerImpl(ParseLayer parseObj, GenElem* parent)
{
    return std::make_unique<CSizeLayer>(*this, parseObj, parent);
}

CGenerator::GenLayerPtr CGenerator::genCreateIdLayerImpl(ParseLayer parseObj, GenElem* parent)
{
    return std::make_unique<CIdLayer>(*this, parseObj, parent);
}

CGenerator::GenLayerPtr CGenerator::genCreateValueLayerImpl(ParseLayer parseObj, GenElem* parent)
{
    return std::make_unique<CValueLayer>(*this, parseObj, parent);
}

CGenerator::GenLayerPtr CGenerator::genCreatePayloadLayerImpl(ParseLayer parseObj, GenElem* parent)
{
    return std::make_unique<CPayloadLayer>(*this, parseObj, parent);
}

CGenerator::GenLayerPtr CGenerator::genCreateChecksumLayerImpl(ParseLayer parseObj, GenElem* parent)
{
    return std::make_unique<CChecksumLayer>(*this, parseObj, parent);
}

CGenerator::OptsProcessResult CGenerator::genProcessOptionsImpl(const GenProgramOptions& options)
{
    auto& opts = CProgramOptions::cCast(options);

    cSetNamesPrefixInternal(opts.cGetNamesPrefix());
    cSetCommsOptionsInternal(opts.cGetCommsOptions());
    cSetCommsInterfaceInternal(opts.cGetCommsInterface());
    cSetCommsInputInternal(opts.cGetCommsInput());
    genSetTopNamespace("cc_c");
    return OptsProcessResult_Continue;
}

bool CGenerator::cWriteExtraFilesInternal() const
{
    const std::vector<std::string> ReservedExt = {
    };

    return genCopyExtraSourceFiles(ReservedExt);
}

void CGenerator::cSetNamesPrefixInternal(const std::string& value)
{
    m_namesPrefix = util::genStrToName(value);
}

void CGenerator::cSetCommsOptionsInternal(const std::string& value)
{
    m_commsOptions = util::genStrSplit(value, ",");
}

void CGenerator::cSetCommsInputInternal(const std::string& value)
{
    m_inputName = value;
}

void CGenerator::cSetCommsInterfaceInternal(const std::string& value)
{
    m_forcedInterfaceName = value;
}

bool CGenerator::cPrepareNamesPrefixInternal()
{
    if (m_namesPrefix.empty()) {
        m_namesPrefix = genProtocolSchema().genMainNamespace();
    }
    return true;
}

bool CGenerator::cPrepareCommsOptionsInternal()
{
    auto& schemas = genSchemas();
    while (m_commsOptions.size() < schemas.size()) {
        if (!schemas[m_commsOptions.size()]->genHasAnyReferencedComponent()) {
            m_commsOptions.push_back(strings::genEmptyString());
            continue;
        }

        m_commsOptions.push_back(strings::genDefaultOptionsClassStr());
    }

    for (auto idx = 0U; idx < m_commsOptions.size(); ++idx) {
        auto& optStr = m_commsOptions[idx];
        if (optStr.empty()) {
            continue;
        }

        auto scopePos = optStr.find("::");
        if (scopePos != std::string::npos) {
            continue;
        }

        if (schemas.size() <= idx) {
            genLogger().genError("Unable to determine options scope from \"" + optStr + "\" options string.");
            return false;
        }

        optStr = schemas[idx]->genMainNamespace() + "::" + comms::genScopeForOptions(optStr, *this, false, true);
    }

    // Clean empty strings
    m_commsOptions.erase(
        std::remove_if(
            m_commsOptions.begin(), m_commsOptions.end(),
            [](auto& str)
            {
                return str.empty();
            }),
        m_commsOptions.end());

    return true;
}

bool CGenerator::cPrepareForcedInterfaceInternal()
{
    if (m_forcedInterfaceName.empty()) {
        return true;
    }

    auto* iFace = genFindInterface(m_forcedInterfaceName);
    if (iFace == nullptr) {
        genLogger().genError("Unknown forced interface \"" + m_forcedInterfaceName + "\"");
        return false;
    }

    m_forcedInterface = CInterface::cCast(iFace);
    return true;
}

bool CGenerator::cPrepareInputNameInternal()
{
    if (m_inputName.empty()) {
        m_inputName = strings::genAllMessagesStr();
    }
    return true;
}

} // namespace commsdsl2c
