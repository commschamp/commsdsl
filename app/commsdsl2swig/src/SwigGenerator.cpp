//
// Copyright 2021 - 2025 (C). Alex Robenko. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "SwigGenerator.h"

#include "Swig.h"
#include "SwigBitfieldField.h"
#include "SwigBundleField.h"
#include "SwigChecksumLayer.h"
#include "SwigCmake.h"
#include "SwigComms.h"
#include "SwigCustomLayer.h"
#include "SwigDataBuf.h"
#include "SwigDataField.h"
#include "SwigEnumField.h"
#include "SwigFloatField.h"
#include "SwigFrame.h"
#include "SwigIdLayer.h"
#include "SwigInterface.h"
#include "SwigIntField.h"
#include "SwigListField.h"
#include "SwigMessage.h"
#include "SwigMsgHandler.h"
#include "SwigNamespace.h"
#include "SwigOptionalField.h"
#include "SwigPayloadLayer.h"
#include "SwigRefField.h"
#include "SwigSchema.h"
#include "SwigSetField.h"
#include "SwigSizeLayer.h"
#include "SwigStringField.h"
#include "SwigSyncLayer.h"
#include "SwigValueLayer.h"
#include "SwigVariantField.h"
#include "SwigVersion.h"

#include "commsdsl/gen/comms.h"
#include "commsdsl/gen/strings.h"
#include "commsdsl/gen/util.h"
#include "commsdsl/version.h"

#include <algorithm>
#include <cassert>
#include <fstream>
#include <filesystem>
#include <map>

namespace comms = commsdsl::gen::comms;
namespace fs = std::filesystem;
namespace strings = commsdsl::gen::strings;
namespace util = commsdsl::gen::util;

namespace commsdsl2swig
{

SwigGenerator::SwigGenerator()
{
    GenBase::genSetAllInterfacesReferencedByDefault(false);
    GenBase::genSetAllMessagesReferencedByDefault(false);
}    

const std::string& SwigGenerator::swigFileGeneratedComment()
{
    static const std::string Str =
        "// Generated by commsdsl2swig v" + std::to_string(commsdsl::versionMajor()) +
        '.' + std::to_string(commsdsl::versionMinor()) + '.' +
        std::to_string(commsdsl::versionPatch()) + '\n';
    return Str;
}

std::string SwigGenerator::swigInputCodePathFor(const commsdsl::gen::GenElem& elem) const
{
    return genGetCodeDir() + '/' + strings::genIncludeDirStr() + '/' + comms::genRelHeaderPathFor(elem, *this);
}

std::string SwigGenerator::swigInputCodePathForFile(const std::string& name) const
{
    return genGetCodeDir() + '/' + name;
}

std::string SwigGenerator::swigClassName(const commsdsl::gen::GenElem& elem) const
{
    bool addMainNamespace = m_mainNamespaceInNamesForced || (genSchemas().size() > 1U); 
    auto str = comms::genScopeFor(elem, *this, addMainNamespace);
    return swigScopeToName(str);
}

std::string SwigGenerator::swigScopeNameForRoot(const std::string& name) const
{
    bool addMainNamespace = m_mainNamespaceInNamesForced || (genSchemas().size() > 1U); 
    auto str = comms::genScopeForRoot(name, *this, addMainNamespace);
    return swigScopeToName(str);
}

std::string SwigGenerator::swigScopeNameForMsgId(const std::string& name, const SwigNamespace& parent) const
{
    bool addMainNamespace = m_mainNamespaceInNamesForced || (genSchemas().size() > 1U); 
    auto str = comms::genScopeForMsgId(name, *this, parent, addMainNamespace);
    return swigScopeToName(str);
}

std::string SwigGenerator::swigProtocolClassNameForRoot(const std::string& name) const
{
    bool addMainNamespace = m_mainNamespaceInNamesForced || (genSchemas().size() > 1U); 
    auto schemaIdx = genCurrentSchemaIdx();
    genChooseProtocolSchema();
    auto str = comms::genScopeForRoot(name, *this, addMainNamespace);
    genChooseCurrentSchema(schemaIdx);
    return swigScopeToName(str);
}

const std::string& SwigGenerator::swigConvertCppType(const std::string& str) const
{
    static const std::map<std::string, std::string> Map = {
        {"std::int8_t", "signed char"},
        {"std::uint8_t", "unsigned char"},
        {"std::int16_t", "short"},
        {"std::uint16_t", "unsigned short"},
        {"std::int32_t", "int"},
        {"std::uint32_t", "unsigned"},
        {"std::int64_t", "long long"},
        {"std::uint64_t", "unsigned long long"},
        {"std::size_t", "unsigned long"},        
    };

    auto iter = Map.find(str);
    if (iter == Map.end()) {
        return str;
    }

    return iter->second;
}

const std::string& SwigGenerator::swigConvertIntType(commsdsl::parse::ParseIntField::ParseType value, std::size_t len) const
{
    return swigConvertCppType(comms::genCppIntTypeFor(value, len));
}

std::string SwigGenerator::swigScopeToName(const std::string& scope)
{
    return util::genStrReplace(scope, "::", "_");
}

std::string SwigGenerator::swigDefInclude(const std::string& path)
{
    return "%include \"include/" + path + '\"';
}

bool SwigGenerator::genCreateCompleteImpl()
{
    return 
        swigReferenceRequestedInterfaceInternal() &&
        swigReferenceRequestedMessagesInternal();
}

bool SwigGenerator::genPrepareImpl()
{
    if (!GenBase::genPrepareImpl()) {
        return false;
    }

    if (m_forcedInterface.empty()) {
        return true;
    }
    
    auto* iFace = genFindInterface(m_forcedInterface);
    if (iFace == nullptr) {
        genLogger().genError("The selected forced interface \"" + m_forcedInterface + "\" hasn't been found");
        return false;
    }

    return true;
}

bool SwigGenerator::genWriteImpl()
{
    for (auto idx = 0U; idx < genSchemas().size(); ++idx) {
        genChooseCurrentSchema(idx);
        bool result = 
            SwigVersion::swigWrite(*this);

        if (!result) {
            return false;
        }
    }

    return 
        SwigComms::swigWrite(*this) &&
        SwigDataBuf::swigWrite(*this) &&
        SwigMsgHandler::swigWrite(*this) &&
        Swig::swigWrite(*this) &&
        SwigCmake::swigWrite(*this) &&
        swigWriteExtraFilesInternal();

}

void SwigGenerator::swigSetMainNamespaceInNamesForced(bool value)
{
    m_mainNamespaceInNamesForced = value;
}

void SwigGenerator::swigSetForcedInterface(const std::string& value)
{
    m_forcedInterface = value;
}

void SwigGenerator::swigSetHasProtocolVersion(bool value)
{
    m_hasProtocolVersion = value;
}

void SwigGenerator::swigSetMessagesListFile(const std::string& value)
{
    m_messagesListFile = value;
}

void SwigGenerator::swigSetForcedPlatform(const std::string& value)
{
    m_forcedPlatform = value;
}

bool SwigGenerator::swigHasProtocolVersion() const
{
    return m_hasProtocolVersion;
}

const SwigInterface* SwigGenerator::swigMainInterface() const
{
    do {
        if (m_forcedInterface.empty()) {
            break;
        }

        auto iFace = genFindInterface(m_forcedInterface);
        if (iFace == nullptr) {
            break;
        }

        return static_cast<const SwigInterface*>(iFace);
    } while (false);

    auto allInterfaces = genGetAllInterfaces();
    if (allInterfaces.empty()) {
        return nullptr;
    }
    return static_cast<const SwigInterface*>(allInterfaces.front());
}

SwigInterface* SwigGenerator::swigMainInterface()
{
    return const_cast<SwigInterface*>(static_cast<const SwigGenerator*>(this)->swigMainInterface());
}

SwigGenerator::GenSchemaPtr SwigGenerator::genCreateSchemaImpl(commsdsl::parse::ParseSchema parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigSchema>(*this, parseObj, parent);
}

SwigGenerator::GenNamespacePtr SwigGenerator::genCreateNamespaceImpl(commsdsl::parse::ParseNamespace parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigNamespace>(*this, parseObj, parent);
}

SwigGenerator::GenInterfacePtr SwigGenerator::genCreateInterfaceImpl(commsdsl::parse::ParseInterface parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigInterface>(*this, parseObj, parent);
}

SwigGenerator::GenMessagePtr SwigGenerator::genCreateMessageImpl(commsdsl::parse::ParseMessage parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigMessage>(*this, parseObj, parent);
}

SwigGenerator::GenFramePtr SwigGenerator::genCreateFrameImpl(commsdsl::parse::ParseFrame parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigFrame>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateIntFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigIntField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateEnumFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigEnumField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateSetFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigSetField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateFloatFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigFloatField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateBitfieldFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigBitfieldField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateBundleFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigBundleField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateStringFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigStringField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateDataFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigDataField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateListFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigListField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateRefFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigRefField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateOptionalFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigOptionalField>(*this, parseObj, parent);
}

SwigGenerator::GenFieldPtr SwigGenerator::genCreateVariantFieldImpl(commsdsl::parse::ParseField parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigVariantField>(*this, parseObj, parent);
}

SwigGenerator::GenLayerPtr SwigGenerator::genCreateCustomLayerImpl(commsdsl::parse::ParseLayer parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigCustomLayer>(*this, parseObj, parent);
}

SwigGenerator::GenLayerPtr SwigGenerator::genCreateSyncLayerImpl(commsdsl::parse::ParseLayer parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigSyncLayer>(*this, parseObj, parent);
}

SwigGenerator::GenLayerPtr SwigGenerator::genCreateSizeLayerImpl(commsdsl::parse::ParseLayer parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigSizeLayer>(*this, parseObj, parent);
}

SwigGenerator::GenLayerPtr SwigGenerator::genCreateIdLayerImpl(commsdsl::parse::ParseLayer parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigIdLayer>(*this, parseObj, parent);
}

SwigGenerator::GenLayerPtr SwigGenerator::genCreateValueLayerImpl(commsdsl::parse::ParseLayer parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigValueLayer>(*this, parseObj, parent);
}

SwigGenerator::GenLayerPtr SwigGenerator::genCreatePayloadLayerImpl(commsdsl::parse::ParseLayer parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigPayloadLayer>(*this, parseObj, parent);
}

SwigGenerator::GenLayerPtr SwigGenerator::genCreateChecksumLayerImpl(commsdsl::parse::ParseLayer parseObj, commsdsl::gen::GenElem* parent)
{
    return std::make_unique<SwigChecksumLayer>(*this, parseObj, parent);
}

bool SwigGenerator::swigWriteExtraFilesInternal() const
{
    const std::vector<std::string> ReservedExt = {
        strings::genReplaceFileSuffixStr(),
        strings::genExtendFileSuffixStr(),
        strings::genPublicFileSuffixStr(),
        strings::genIncFileSuffixStr(),
        strings::genAppendFileSuffixStr(),
        strings::genPrependFileSuffixStr(),
        strings::genPrependLangFileSuffixStr(),
        strings::genSourcesFileSuffixStr(),
    }; 

    return genCopyExtraSourceFiles(ReservedExt);
}

bool SwigGenerator::swigReferenceRequestedInterfaceInternal()
{
    auto* mainInterface = swigMainInterface();
    if (mainInterface != nullptr) {
        mainInterface->genSetReferenced(true);
    }

    return true;
}

bool SwigGenerator::swigReferenceRequestedMessagesInternal()
{
    if ((m_messagesListFile.empty()) && (m_forcedPlatform.empty())) {
        genReferenceAllMessages();
        return true;
    }

    if ((!m_messagesListFile.empty()) && (!m_forcedPlatform.empty())) {
        genLogger().genError("Cannot force platform messages together with explicit message list.");
        return false;
    }    

    if (!m_messagesListFile.empty()) {
        return swigProcessMessagesListFileInternal();
    }

    if (!m_forcedPlatform.empty()) {
        return swigProcessForcedPlatformInternal();
    }    

    return true;
}

bool SwigGenerator::swigProcessMessagesListFileInternal()
{
    std::ifstream stream(m_messagesListFile);
    if (!stream) {
        genLogger().genError("Failed to open messages list file: \"" + m_messagesListFile + "\".");
        return false;
    }

    std::string contents(std::istreambuf_iterator<char>(stream), (std::istreambuf_iterator<char>()));
    auto lines = util::genStrSplitByAnyChar(contents, "\n\r");

    for (auto& l : lines) {
        auto* m = genGindMessage(l);
        if (m == nullptr) {
            genLogger().genError("Failed to fined message \"" + l + "\" listed in \"" + m_messagesListFile + "\".");
            return false;
        }

        m->genSetReferenced(true);
    }

    return true;
}

bool SwigGenerator::swigProcessForcedPlatformInternal()
{
    bool validPlatform = false;

    assert(!m_forcedPlatform.empty());
    for (auto* m : genGetAllMessages()) {
        assert(m != nullptr);
        auto& s = genSchemaOf(*m);
        auto& schemaPlatforms = s.genParseObj().parsePlatforms();
        auto iter = std::find(schemaPlatforms.begin(), schemaPlatforms.end(), m_forcedPlatform);
        if (iter == schemaPlatforms.end()) {
            continue;
        }

        validPlatform = true;

        auto* swigM = const_cast<SwigMessage*>(SwigMessage::swigCast(m));
        auto& messagePlatforms = swigM->genParseObj().parsePlatforms();

        bool messageSupported = 
            (messagePlatforms.empty()) || 
            (std::find(messagePlatforms.begin(), messagePlatforms.end(), m_forcedPlatform) != messagePlatforms.end());

        if (messageSupported) {
            swigM->genSetReferenced(true);
        }
    }
    
    if (!validPlatform) {
        genLogger().genError("Unknown platform: \"" + m_forcedPlatform + "\".");
        return false;
    }

    return true;
}

} // namespace commsdsl2swig
